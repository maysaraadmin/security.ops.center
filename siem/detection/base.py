"""
Base classes for threat detection and alerting in SIEM.
"""
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Type, TypeVar, Union
from datetime import datetime, timedelta
import json
import logging
import hashlib

class ThreatDetector(ABC):
    """Abstract base class for all threat detectors."""
    
    def __init__(self, config: Dict[str, Any] = None):
        """Initialize the detector with configuration."""
        self.config = config or {}
        self.detector_id = self.config.get('id', self.__class__.__name__)
        self.name = self.config.get('name', self.detector_id)
        self.severity = self.config.get('severity', 'medium')
        self.enabled = self.config.get('enabled', True)
        self.logger = logging.getLogger(f"siem.detector.{self.detector_id}")
        self._setup()
    
    @abstractmethod
    def _setup(self) -> None:
        """Perform any necessary setup for the detector."""
        pass
    
    @abstractmethod
    def detect(self, event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Analyze an event for threats.
        
        Args:
            event: The event to analyze
            
        Returns:
            Alert if a threat is detected, None otherwise
        """
        pass
    
    def generate_alert(
        self, 
        event: Dict[str, Any],
        signature: str,
        description: str,
        **kwargs
    ) -> Dict[str, Any]:
        """Generate a standardized alert.
        
        Args:
            event: The event that triggered the alert
            signature: Short description of the threat
            description: Detailed description of the threat
            **kwargs: Additional fields to include in the alert
            
        Returns:
            Alert dictionary
        """
        # Create a unique alert ID based on the event and signature
        alert_id = hashlib.sha256(
            f"{event.get('@timestamp')}{signature}{json.dumps(event, sort_keys=True)}"
            .encode('utf-8')
        ).hexdigest()
        
        # Get related entities
        related = {
            'hosts': [],
            'users': [],
            'ips': [],
            'hashes': []
        }
        
        # Extract related entities from event
        for entity_type in ['host', 'user', 'source', 'destination', 'file', 'process']:
            if entity_type in event:
                if entity_type == 'host' and 'name' in event[entity_type]:
                    related['hosts'].append(event[entity_type]['name'])
                elif entity_type == 'user' and 'name' in event[entity_type]:
                    related['users'].append(event[entity_type]['name'])
                elif entity_type == 'source' and 'ip' in event[entity_type]:
                    related['ips'].append(event[entity_type]['ip'])
                elif entity_type == 'file' and 'hash' in event[entity_type]:
                    related['hashes'].append(event[entity_type]['hash'])
        
        # Create the alert
        alert = {
            '@timestamp': datetime.utcnow().isoformat() + 'Z',
            'event': {
                'kind': 'alert',
                'category': 'threat',
                'type': ['detection'],
                'severity': self.severity,
                'signature': signature,
                'description': description,
                'original': json.dumps(event)
            },
            'threat': {
                'detector': {
                    'id': self.detector_id,
                    'name': self.name,
                    'type': self.__class__.__name__
                },
                'technique': [],
                'tactic': [],
                'signature': signature,
                'confidence': self.config.get('confidence', 'medium')
            },
            'related': {k: v for k, v in related.items() if v},
            'message': f"{signature}: {description}",
            'tags': ['threat', 'alert', 'siem'] + self.config.get('tags', []),
            'alert_id': alert_id
        }
        
        # Add any additional fields
        alert.update(kwargs)
        
        return alert


class AlertManager:
    """Manages alerts generated by threat detectors."""
    
    def __init__(self, config: Dict[str, Any] = None):
        """Initialize the alert manager."""
        self.config = config or {}
        self.logger = logging.getLogger("siem.alert.manager")
        self.alerts: Dict[str, Dict[str, Any]] = {}
        self._setup()
    
    def _setup(self) -> None:
        """Set up the alert manager."""
        self.retention = timedelta(
            hours=self.config.get('alert_retention_hours', 24)
        )
    
    def add_alert(self, alert: Dict[str, Any]) -> str:
        """Add an alert to the manager.
        
        Args:
            alert: The alert to add
            
        Returns:
            The alert ID
        """
        alert_id = alert.get('alert_id')
        if not alert_id:
            alert_id = hashlib.sha256(
                json.dumps(alert, sort_keys=True).encode('utf-8')
            ).hexdigest()
            alert['alert_id'] = alert_id
        
        # Add timestamp if not present
        if '@timestamp' not in alert:
            alert['@timestamp'] = datetime.utcnow().isoformat() + 'Z'
        
        # Store the alert
        self.alerts[alert_id] = alert
        self.logger.info(
            f"New alert: {alert.get('event', {}).get('signature')} "
            f"(severity: {alert.get('event', {}).get('severity', 'unknown')})"
        )
        
        return alert_id
    
    def get_alert(self, alert_id: str) -> Optional[Dict[str, Any]]:
        """Get an alert by ID.
        
        Args:
            alert_id: The ID of the alert to retrieve
            
        Returns:
            The alert, or None if not found
        """
        return self.alerts.get(alert_id)
    
    def get_alerts(
        self,
        severity: Optional[Union[str, List[str]]] = None,
        time_range: Optional[timedelta] = None,
        limit: int = 100
    ) -> List[Dict[str, Any]]:
        """Get alerts matching the specified criteria.
        
        Args:
            severity: Severity level(s) to filter by
            time_range: Maximum age of alerts to return
            limit: Maximum number of alerts to return
            
        Returns:
            List of matching alerts, sorted by timestamp (newest first)
        """
        if severity is not None and not isinstance(severity, list):
            severity = [severity]
        
        now = datetime.utcnow()
        min_time = now - time_range if time_range else None
        
        filtered = []
        for alert in self.alerts.values():
            # Filter by severity
            if severity and alert.get('event', {}).get('severity') not in severity:
                continue
                
            # Filter by time
            if min_time:
                alert_time = datetime.fromisoformat(
                    alert['@timestamp'].replace('Z', '+00:00')
                )
                if alert_time < min_time:
                    continue
            
            filtered.append(alert)
        
        # Sort by timestamp (newest first) and apply limit
        filtered.sort(
            key=lambda x: x['@timestamp'],
            reverse=True
        )
        
        return filtered[:limit]
    
    def cleanup_old_alerts(self) -> int:
        """Remove alerts older than the retention period.
        
        Returns:
            Number of alerts removed
        """
        now = datetime.utcnow()
        min_time = now - self.retention
        
        initial_count = len(self.alerts)
        
        self.alerts = {
            alert_id: alert
            for alert_id, alert in self.alerts.items()
            if datetime.fromisoformat(
                alert['@timestamp'].replace('Z', '+00:00')
            ) >= min_time
        }
        
        removed = initial_count - len(self.alerts)
        if removed > 0:
            self.logger.info(f"Cleaned up {removed} old alerts")
            
        return removed
