""\nDLP Alerts and Incident Response Module\n\nThis module provides real-time alerting and incident response capabilities for DLP policy violations.\n"""\nimport logging\nimport json\nimport smtplib\nimport socket\nfrom datetime import datetime\nfrom dataclasses import dataclass, asdict\nfrom enum import Enum, auto\nfrom typing import Dict, List, Optional, Any, Union, Callable\nfrom pathlib import Path\nimport yaml\n\nlogger = logging.getLogger(__name__)\n\nclass AlertSeverity(Enum):\n    """Severity levels for DLP alerts."""\n    LOW = auto()\n    MEDIUM = auto()\n    HIGH = auto()\n    CRITICAL = auto()\n\nclass AlertStatus(Enum):\n    """Status of an alert."""\n    OPEN = "open"\n    IN_PROGRESS = "in_progress"\n    CLOSED = "closed"\n    FALSE_POSITIVE = "false_positive"\n\n@dataclass\nclass AlertContext:\n    """Contextual information about a DLP policy violation."""\n    policy_id: str\n    rule_id: str\n    action_taken: str\n    severity: AlertSeverity\n    source_ip: Optional[str] = None\n    destination_ip: Optional[str] = None\n    username: Optional[str] = None\n    file_path: Optional[str] = None\n    url: Optional[str] = None\n    content_sample: Optional[str] = None\n    matched_pattern: Optional[str] = None\n    metadata: Optional[Dict[str, Any]] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        """Convert alert context to dictionary."""\n        result = asdict(self)\n        result['severity'] = self.severity.name\n        return result\n\n@dataclass\nclass Alert:\n    """Represents a DLP alert/incident."""\n    alert_id: str\n    timestamp: datetime\n    context: AlertContext\n    status: AlertStatus = AlertStatus.OPEN\n    assigned_to: Optional[str] = None\n    comments: List[Dict[str, str]] = None\n    resolution: Optional[str] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        """Convert alert to dictionary."""\n        return {\n            'alert_id': self.alert_id,\n            'timestamp': self.timestamp.isoformat(),\n            'context': self.context.to_dict(),\n            'status': self.status.value,\n            'assigned_to': self.assigned_to,\n            'comments': self.comments or [],\n            'resolution': self.resolution\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'Alert':\n        """Create Alert from dictionary."""\n        context_data = data.get('context', {})\n        return cls(\n            alert_id=data['alert_id'],\n            timestamp=datetime.fromisoformat(data['timestamp']),\n            context=AlertContext(\n                policy_id=context_data['policy_id'],\n                rule_id=context_data['rule_id'],\n                action_taken=context_data['action_taken'],\n                severity=AlertSeverity[context_data['severity']],\n                source_ip=context_data.get('source_ip'),\n                destination_ip=context_data.get('destination_ip'),\n                username=context_data.get('username'),\n                file_path=context_data.get('file_path'),\n                url=context_data.get('url'),\n                content_sample=context_data.get('content_sample'),\n                matched_pattern=context_data.get('matched_pattern'),\n                metadata=context_data.get('metadata', {})\n            ),\n            status=AlertStatus(data['status']),\n            assigned_to=data.get('assigned_to'),\n            comments=data.get('comments', []),\n            resolution=data.get('resolution')\n        )\n\nclass AlertManager:\n    """Manages DLP alerts and incident response."""\n    \n    def __init__(self, storage_path: str = "dlp_alerts"):\n        """Initialize the alert manager.\n        \n        Args:\n            storage_path: Directory to store alert data\n        """\n        self.storage_path = Path(storage_path)\n        self.storage_path.mkdir(parents=True, exist_ok=True)\n        self._alert_handlers = []\n    \n    def add_handler(self, handler: Callable[['Alert'], None]):\n        """Add an alert handler function.\n        \n        Handlers will be called when new alerts are created.\n        """\n        self._alert_handlers.append(handler)\n    \n    async def create_alert(self, context: AlertContext) -> Alert:\n        """Create a new DLP alert.\n        \n        Args:\n            context: Alert context with violation details\n            \n        Returns:\n            The created alert\n        """\n        alert_id = f"dlp_alert_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{context.rule_id}"\n        alert = Alert(\n            alert_id=alert_id,\n            timestamp=datetime.utcnow(),\n            context=context,\n            status=AlertStatus.OPEN\n        )\n        \n        # Save the alert\n        await self._save_alert(alert)\n        \n        # Notify handlers\n        for handler in self._alert_handlers:\n            try:\n                handler(alert)\n            except Exception as e:\n                logger.error(f"Error in alert handler: {e}", exc_info=True)\n        \n        return alert\n    \n    async def update_alert(self, alert_id: str, updates: Dict[str, Any]) -> Optional[Alert]:\n        """Update an existing alert.\n        \n        Args:\n            alert_id: ID of the alert to update\n            updates: Dictionary of fields to update\n            \n        Returns:\n            Updated alert or None if not found\n        """\n        alert_path = self.storage_path / f"{alert_id}.json"\n        if not alert_path.exists():\n            return None\n            \n        with open(alert_path, 'r') as f:\n            alert_data = json.load(f)\n        \n        alert = Alert.from_dict(alert_data)\n        \n        # Apply updates\n        for key, value in updates.items():\n            if hasattr(alert, key):\n                if key == 'status' and isinstance(value, str):\n                    value = AlertStatus(value)\n                setattr(alert, key, value)\n        \n        # Save updated alert\n        await self._save_alert(alert)\n        return alert\n    \n    async def get_alert(self, alert_id: str) -> Optional[Alert]:\n        """Retrieve an alert by ID."""\n        alert_path = self.storage_path / f"{alert_id}.json"\n        if not alert_path.exists():\n            return None\n            \n        with open(alert_path, 'r') as f:\n            alert_data = json.load(f)\n        \n        return Alert.from_dict(alert_data)\n    \n    async def list_alerts(\n        self,\n        status: Optional[AlertStatus] = None,\n        severity: Optional[AlertSeverity] = None,\n        limit: int = 100,\n        offset: int = 0\n    ) -> List[Alert]:\n        """List alerts with optional filtering."""\n        alerts = []\n        count = 0\n        \n        for alert_file in sorted(self.storage_path.glob("*.json"), key=lambda p: p.name, reverse=True):\n            if count >= offset + limit:\n                break\n                \n            try:\n                with open(alert_file, 'r') as f:\n                    alert_data = json.load(f)\n                \n                alert = Alert.from_dict(alert_data)\n                \n                # Apply filters\n                if status is not None and alert.status != status:\n                    continue\n                if severity is not None and alert.context.severity != severity:\n                    continue\n                    \n                if count >= offset:\n                    alerts.append(alert)\n                count += 1\n                \n            except Exception as e:\n                logger.error(f"Error loading alert from {alert_file}: {e}")\n        \n        return alerts\n    \n    async def _save_alert(self, alert: Alert):\n        """Save alert to storage."""\n        alert_path = self.storage_path / f"{alert.alert_id}.json"\n        with open(alert_path, 'w') as f:\n            json.dump(alert.to_dict(), f, indent=2, default=str)\n\nclass EmailNotifier:\n    """Sends email notifications for DLP alerts."""\n    \n    def __init__(self, smtp_server: str, smtp_port: int, \n                 sender: str, username: str = None, \n                 password: str = None, use_tls: bool = True):\n        self.smtp_server = smtp_server\n        self.smtp_port = smtp_port\n        self.sender = sender\n        self.username = username\n        self.password = password\n        self.use_tls = use_tls\n    \n    def __call__(self, alert: Alert, recipients: List[str]):\n        """Send email notification about the alert."""\n        subject = f"[DLP Alert] {alert.context.policy_id} - {alert.context.rule_id}"\n        \n        # Format the email body\n        body = f"""\n        DLP Policy Violation Detected!\n        =============================\n        \n        Alert ID: {alert.alert_id}\n        Timestamp: {alert.timestamp}\n        Severity: {alert.context.severity.name}\n        \n        Policy: {alert.context.policy_id}\n        Rule: {alert.context.rule_id}\n        Action Taken: {alert.context.action_taken}\n        \n        Source IP: {alert.context.source_ip or 'N/A'}\n        Username: {alert.context.username or 'N/A'}\n        \n        Details:\n        {details}\n        """.format(\n            alert=alert,\n            details=json.dumps(alert.context.metadata or {}, indent=2) if alert.context.metadata else "No additional details"\n        )\n        \n        message = f"From: {self.sender}\nTo: {', '.join(recipients)}\nSubject: {subject}\n\n{body}"\n        \n        try:\n            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:\n                if self.use_tls:\n                    server.starttls()\n                if self.username and self.password:\n                    server.login(self.username, self.password)\n                server.sendmail(self.sender, recipients, message)\n            logger.info(f"Alert notification sent to {', '.join(recipients)}")\n        except Exception as e:\n            logger.error(f"Failed to send email notification: {e}", exc_info=True)\n\n# Default alert manager instance\nalert_manager = AlertManager()\n\n# Example usage\nif __name__ == "__main__":\n    import asyncio\n    \n    async def test_alerting():\n        # Create a test alert\n        context = AlertContext(\n            policy_id="block_sensitive_data",\n            rule_id="block_credit_cards",\n            action_taken="blocked",\n            severity=AlertSeverity.HIGH,\n            source_ip="192.168.1.100",\n            username="jdoe",\n            content_sample="Card number 4111111111111111 detected",\n            matched_pattern="\\b(?:4[0-9]{12}(?:[0-9]{3})?)\\b"\n        )\n        \n        # Create the alert\n        alert = await alert_manager.create_alert(context)\n        print(f"Created alert: {alert.alert_id}")\n        \n        # List alerts\n        alerts = await alert_manager.list_alerts()\n        print(f"Found {len(alerts)} alerts")\n        \n        # Update alert\n        await alert_manager.update_alert(\n            alert.alert_id,\n            {"status": AlertStatus.IN_PROGRESS, "assigned_to": "admin@example.com"}\n        )\n        \n        # Get updated alert\n        updated_alert = await alert_manager.get_alert(alert.alert_id)\n        print(f"Updated status: {updated_alert.status}")\n    \n    asyncio.run(test_alerting())
