"""
TLS/SSL Inspection Module for NIPS\n"""\nimport ssl\nimport socket\nimport logging\nimport tempfile\nimport os\nfrom dataclasses import dataclass, field\nfrom enum import Enum, auto\nfrom typing import Optional, Dict, List, Tuple, Any, Union, Callable\nfrom pathlib import Path\nimport threading\nimport time\nimport json\nimport hashlib\nimport re\nimport ipaddress\nfrom cryptography import x509\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.x509.oid import ExtensionOID, NameOID\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger('nips.tls_inspect')\n\nclass TLSInspectionError(Exception):\n    """Base exception for TLS inspection errors."""\n    pass\n\nclass TLSAction(Enum):\n    """Actions to take for TLS traffic."""\n    ALLOW = auto()\n    BLOCK = auto()\n    DECRYPT = auto()  # Decrypt and inspect\n    LOG = auto()      # Allow but log details\n    QUARANTINE = auto()  # Quarantine the source\n\nclass TLSAlertLevel(Enum):\n    """TLS Alert levels."""\n    WARNING = 1\n    FATAL = 2\n\nclass TLSCipherStrength(Enum):\n    """TLS cipher strength classification."""\n    WEAK = "weak"         # < 112 bits\n    MEDIUM = "medium"     # 112-127 bits\n    STRONG = "strong"     # 128-255 bits\n    FUTURE_PROOF = "fp"   # 256+ bits\n\n@dataclass\nclass TLSCertificate:\n    """Represents a TLS certificate with parsed information."""\n    subject: Dict[str, str]\n    issuer: Dict[str, str]\n    serial_number: int\n    not_valid_before: datetime\n    not_valid_after: datetime\n    public_key: Dict[str, Any]\n    extensions: Dict[str, Any]\n    signature_algorithm: str\n    version: int\n    fingerprint: str\n    san_dns: List[str] = field(default_factory=list)\n    san_ip: List[str] = field(default_factory=list)\n    is_self_signed: bool = False\n    is_ca: bool = False\n    key_usage: List[str] = field(default_factory=list)\n    extended_key_usage: List[str] = field(default_factory=list)\n    \n    @classmethod\n    def from_cryptography(cls, cert: x509.Certificate) -> 'TLSCertificate':\n        """Create from cryptography.x509.Certificate."""\n        subject = {attr.oid._name: attr.value for attr in cert.subject}\n        issuer = {attr.oid._name: attr.value for attr in cert.issuer}\n        \n        # Get SANs\n        san_dns = []\n        san_ip = []\n        try:\n            san_ext = cert.extensions.get_extension_for_oid(\n                ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n            )\n            for name in san_ext.value:\n                if isinstance(name, x509.DNSName):\n                    san_dns.append(name.value)\n                elif isinstance(name, x509.IPAddress):\n                    san_ip.append(str(name.value))\n        except x509.ExtensionNotFound:\n            pass\n        \n        # Get key usage\n        key_usage = []\n        try:\n            usage_ext = cert.extensions.get_extension_for_oid(\n                ExtensionOID.KEY_USAGE\n            )\n            for usage in [\n                'digital_signature', 'content_commitment', 'key_encipherment',\n                'data_encipherment', 'key_agreement', 'key_cert_sign',\n                'crl_sign', 'encipher_only', 'decipher_only'\n            ]:\n                if getattr(usage_ext.value, usage, False):\n                    key_usage.append(usage)\n        except x509.ExtensionNotFound:\n            pass\n        \n        # Get extended key usage\n        ext_key_usage = []\n        try:\n            ext_usage = cert.extensions.get_extension_for_oid(\n                ExtensionOID.EXTENDED_KEY_USAGE\n            )\n            for usage in ext_usage.value:\n                ext_key_usage.append(usage._name if hasattr(usage, '_name') else str(usage))\n        except x509.ExtensionNotFound:\n            pass\n        \n        # Get public key info\n        public_key = {\n            'type': cert.public_key().__class__.__name__,\n            'key_size': cert.public_key().key_size,\n        }\n        \n        # Get extensions\n        extensions = {}\n        for ext in cert.extensions:\n            ext_name = ext.oid._name if hasattr(ext.oid, '_name') else str(ext.oid)\n            extensions[ext_name] = str(ext.value)\n        \n        return cls(\n            subject=subject,\n            issuer=issuer,\n            serial_number=cert.serial_number,\n            not_valid_before=cert.not_valid_before,\n            not_valid_after=cert.not_valid_after,\n            public_key=public_key,\n            extensions=extensions,\n            signature_algorithm=cert.signature_hash_algorithm.name if cert.signature_hash_algorithm else 'unknown',\n            version=cert.version.value,\n            fingerprint=cert.fingerprint(hashes.SHA256()).hex(),\n            san_dns=san_dns,\n            san_ip=san_ip,\n            is_self_signed=cert.issuer == cert.subject,\n            is_cert_authority=cert.extensions.get_extension_for_oid(\n                x509.BasicConstraintsOID\n            ).value.ca if cert.extensions.get_extension_for_oid(x509.BasicConstraintsOID) else False,\n            key_usage=key_usage,\n            extended_key_usage=ext_key_usage\n        )\n\n@dataclass\nclass TLSHandshake:\n    """Represents a TLS handshake with extracted information."""\n    timestamp: float\n    src_ip: str\n    src_port: int\n    dst_ip: str\n    dst_port: int\n    server_name: Optional[str] = None\n    version: Optional[str] = None\n    cipher_suite: Optional[str] = None\n    certificate_chain: List[TLSCertificate] = field(default_factory=list)\n    alpn_protocols: List[str] = field(default_factory=list)\n    session_id: Optional[bytes] = None\n    compression_methods: List[str] = field(default_factory=list)\n    extensions: Dict[str, Any] = field(default_factory=dict)\n    ja3_hash: Optional[str] = None\n    ja3s_hash: Optional[str] = None\n    \n    def is_valid(self) -> bool:\n        """Check if the handshake appears valid."""\n        if not self.server_name and not self.dst_ip:\n            return False\n        if not self.version:\n            return False\n        return True\n\n@dataclass\nclass TLSSession:\n    """Represents an ongoing TLS session."""\n    session_id: str\n    start_time: float\n    src_ip: str\n    src_port: int\n    dst_ip: str\n    dst_port: int\n    server_name: Optional[str] = None\n    version: Optional[str] = None\n    cipher_suite: Optional[str] = None\n    certificate_chain: List[TLSCertificate] = field(default_factory=list)\n    alpn_protocol: Optional[str] = None\n    bytes_sent: int = 0\n    bytes_received: int = 0\n    packets_sent: int = 0\n    packets_received: int = 0\n    end_time: Optional[float] = None\n    error: Optional[str] = None\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    \n    @property\n    def duration(self) -> Optional[float]:\n        """Get session duration in seconds."""\n        if self.end_time:\n            return self.end_time - self.start_time\n        return None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        """Convert to a dictionary for serialization."""\n        return {\n            'session_id': self.session_id,\n            'start_time': self.start_time,\n            'end_time': self.end_time,\n            'duration': self.duration,\n            'src_ip': self.src_ip,\n            'src_port': self.src_port,\n            'dst_ip': self.dst_ip,\n            'dst_port': self.dst_port,\n            'server_name': self.server_name,\n            'version': self.version,\n            'cipher_suite': self.cipher_suite,\n            'alpn_protocol': self.alpn_protocol,\n            'bytes_sent': self.bytes_sent,\n            'bytes_received': self.bytes_received,\n            'packets_sent': self.packets_sent,\n            'packets_received': self.packets_received,\n            'error': self.error,\n            'metadata': self.metadata\n        }\n\nclass TLSInspector:\n    """\n    TLS/SSL traffic inspection and decryption engine.\n    \n    This class provides functionality to:\n    1. Inspect TLS handshakes and extract metadata\n    2. Decrypt TLS traffic when private keys are available\n    3. Detect suspicious or malicious TLS usage\n    4. Enforce TLS security policies\n    """\n    \n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        """\n        Initialize the TLS inspector.\n        \n        Args:\n            config: Configuration dictionary with the following optional keys:\n                - private_keys: List of paths to private key files\n                - ca_certificates: List of paths to CA certificate files\n                - enable_mitm: Whether to enable MITM decryption (requires private keys)\n                - min_tls_version: Minimum allowed TLS version ('TLSv1.2', 'TLSv1.3')\n                - allowed_ciphers: List of allowed cipher suites\n                - block_self_signed: Whether to block self-signed certificates\n                - block_expired_certs: Whether to block expired certificates\n                - block_weak_crypto: Whether to block weak crypto (RSA < 2048, SHA1, etc.)\n                - log_all_handshakes: Whether to log all TLS handshakes\n        """\n        self.config = config or {}\n        self.private_keys = self._load_private_keys()\n        self.ca_certificates = self._load_ca_certificates()\n        self.sessions: Dict[str, TLSSession] = {}\n        self.lock = threading.RLock()\n        self.rules = self._load_default_rules()\n        self.mitm_enabled = self.config.get('enable_mitm', False) and bool(self.private_keys)\n        self.session_timeout = self.config.get('session_timeout', 3600)  # seconds\n        self._session_cleaner = threading.Thread(\n            target=self._cleanup_sessions,\n            daemon=True\n        )\n        self._session_cleaner.start()\n    \n    def _load_private_keys(self) -> List[Any]:\n        """Load private keys from configuration."""\n        keys = []\n        for key_path in self.config.get('private_keys', []):\n            try:\n                with open(key_path, 'rb') as f:\n                    # TODO: Implement key loading with cryptography or OpenSSL\n                    # key = serialization.load_pem_private_key(\n                    #     f.read(),\n                    #     password=None,\n                    #     backend=default_backend()\n                    # )\n                    # keys.append(key)\n                    pass\n                logger.info(f"Loaded private key from {key_path}")\n            except Exception as e:\n                logger.error(f"Failed to load private key {key_path}: {e}")\n        return keys\n    \n    def _load_ca_certificates(self) -> List[x509.Certificate]:\n        """Load CA certificates from configuration."""\n        certs = []\n        for cert_path in self.config.get('ca_certificates', []):\n            try:\n                with open(cert_path, 'rb') as f:\n                    cert_data = f.read()\n                    cert = x509.load_pem_x509_certificate(\n                        cert_data,\n                        default_backend()\n                    )\n                    certs.append(cert)\n                logger.info(f"Loaded CA certificate from {cert_path}")\n            except Exception as e:\n                logger.error(f"Failed to load CA certificate {cert_path}: {e}")\n        return certs\n    \n    def _load_default_rules(self) -> List[Dict[str, Any]]:\n        """Load default TLS inspection rules."""\n        return [\n            {\n                'name': 'block_ssl3',\n                'description': 'Block SSL 3.0 and earlier',\n                'condition': lambda h: h.version and h.version.startswith('SSL'),\n                'action': TLSAction.BLOCK,\n                'severity': 'high',\n                'enabled': True\n            },\n            {\n                'name': 'block_tls10',\n                'description': 'Block TLS 1.0',\n                'condition': lambda h: h.version == 'TLSv1.0',\n                'action': TLSAction.BLOCK,\n                'severity': 'medium',\n                'enabled': True\n            },\n            {\n                'name': 'block_tls11',\n                'description': 'Block TLS 1.1',\n                'condition': lambda h: h.version == 'TLSv1.1',\n                'action': TLSAction.BLOCK,\n                'severity': 'medium',\n                'enabled': True\n            },\n            {\n                'name': 'block_weak_ciphers',\n                'description': 'Block weak cipher suites',\n                'condition': self._is_weak_cipher_suite,\n                'action': TLSAction.BLOCK,\n                'severity': 'high',\n                'enabled': True\n            },\n            {\n                'name': 'block_self_signed',\n                'description': 'Block self-signed certificates',\n                'condition': self._is_self_signed_cert,\n                'action': TLSAction.BLOCK,\n                'severity': 'medium',\n                'enabled': self.config.get('block_self_signed', True)\n            },\n            {\n                'name': 'block_expired_certs',\n                'description': 'Block expired certificates',\n                'condition': self._is_cert_expired,\n                'action': TLSAction.BLOCK,\n                'severity': 'high',\n                'enabled': self.config.get('block_expired_certs', True)\n            }\n        ]\n    \n    def _is_weak_cipher_suite(self, handshake: TLSHandshake) -> bool:\n        """Check if the cipher suite is considered weak."""\n        if not handshake.cipher_suite:\n            return False\n            \n        # List of weak ciphers\n        weak_ciphers = {\n            'NULL', 'EXPORT', 'DES', 'RC2', 'RC4', 'MD5', 'SHA1', '3DES', 'CBC', 'PSK', 'SRP', 'KRB5',\n            'CAMELLIA', 'SEED', 'IDEA', 'AES-128', 'AES-256'  # These can be weak in certain modes\n        }\n        \n        # Check if any weak cipher is in the cipher suite name\n        cipher = handshake.cipher_suite.upper()\n        return any(weak in cipher for weak in weak_ciphers)\n    \n    def _is_self_signed_cert(self, handshake: TLSHandshake) -> bool:\n        """Check if the certificate is self-signed."""\n        if not handshake.certificate_chain:\n            return False\n        cert = handshake.certificate_chain[0]  # Server certificate\n        return cert.is_self_signed\n    \n    def _is_cert_expired(self, handshake: TLSHandshake) -> bool:\n        """Check if the certificate is expired or not yet valid."""\n        if not handshake.certificate_chain:\n            return False\n        cert = handshake.certificate_chain[0]  # Server certificate\n        now = datetime.utcnow()\n        return now < cert.not_valid_before or now > cert.not_valid_after\n    \n    def _cleanup_sessions(self):\n        """Background thread to clean up old sessions."""\n        while True:\n            try:\n                now = time.time()\n                to_remove = [\n                    session_id for session_id, session in self.sessions.items()\n                    if session.end_time and (now - session.end_time > self.session_timeout)\n                ]\n                \n                with self.lock:\n                    for session_id in to_remove:\n                        del self.sessions[session_id]\n                \n                time.sleep(60)  # Check every minute\n                \n            except Exception as e:\n                logger.error(f"Error in session cleanup thread: {e}", exc_info=True)\n                time.sleep(10)  # Avoid tight loop on error\n    \n    def inspect_handshake(self, handshake: TLSHandshake) -> Dict[str, Any]:\n        """\n        Inspect a TLS handshake and determine what action to take.\n        \n        Args:\n            handshake: The TLS handshake to inspect\n            \n        Returns:\n            Dict containing:\n                - action: The action to take (ALLOW, BLOCK, etc.)\n                - reason: Reason for the action\n                - severity: Severity level (info, low, medium, high, critical)\n                - metadata: Additional metadata about the decision\n        """\n        if not handshake.is_valid():\n            return {\n                'action': TLSAction.BLOCK,\n                'reason': 'Invalid handshake',\n                'severity': 'high',\n                'metadata': {}\n            }\n        \n        # Apply rules in order\n        for rule in self.rules:\n            if not rule.get('enabled', True):\n                continue\n                \n            try:\n                if rule['condition'](handshake):\n                    return {\n                        'action': rule['action'],\n                        'reason': rule['description'],\n                        'severity': rule.get('severity', 'medium'),\n                        'metadata': {\n                            'rule': rule['name'],\n                            'server_name': handshake.server_name,\n                            'version': handshake.version,\n                            'cipher_suite': handshake.cipher_suite\n                        }\n                    }\n            except Exception as e:\n                logger.error(f"Error applying rule {rule.get('name')}: {e}", exc_info=True)\n        \n        # Default action if no rules match\n        return {\n            'action': TLSAction.ALLOW,\n            'reason': 'No rules matched',\n            'severity': 'info',\n            'metadata': {}\n        }\n    \n    def decrypt_traffic(self, encrypted_data: bytes, session_id: str) -> Optional[bytes]:\n        """\n        Decrypt TLS traffic for a session.\n        \n        Args:\n            encrypted_data: The encrypted TLS data\n            session_id: The session ID\n            \n        Returns:\n            Decrypted data if successful, None otherwise\n        """\n        if not self.mitm_enabled:\n            logger.warning("MITM decryption is not enabled")\n            return None\n            \n        # TODO: Implement decryption using session keys\n        # This would require maintaining session state and keys\n        return None\n    \n    def start_session(self, handshake: TLSHandshake) -> str:\n        """\n        Start tracking a new TLS session.\n        \n        Args:\n            handshake: The initial handshake for the session\n            \n        Returns:\n            Session ID\n        """\n        session_id = hashlib.sha256(\n            f"{handshake.src_ip}:{handshake.src_port}:{handshake.dst_ip}:{handshake.dst_port}:{time.time()}".encode()\n        ).hexdigest()\n        \n        session = TLSSession(\n            session_id=session_id,\n            start_time=time.time(),\n            src_ip=handshake.src_ip,\n            src_port=handshake.src_port,\n            dst_ip=handshake.dst_ip,\n            dst_port=handshake.dst_port,\n            server_name=handshake.server_name,\n            version=handshake.version,\n            cipher_suite=handshake.cipher_suite,\n            certificate_chain=handshake.certificate_chain,\n            alpn_protocol=handshake.alpn_protocols[0] if handshake.alpn_protocols else None\n        )\n        \n        with self.lock:\n            self.sessions[session_id] = session\n        \n        return session_id\n    \n    def update_session(self, session_id: str, data_sent: int = 0, data_received: int = 0) -> bool:\n        """\n        Update session statistics.\n        \n        Args:\n            session_id: The session ID\n            data_sent: Bytes sent in this update\n            data_received: Bytes received in this update\n            \n        Returns:\n            True if session was updated, False if not found\n        """\n        with self.lock:\n            session = self.sessions.get(session_id)\n            if not session:\n                return False\n                \n            session.bytes_sent += data_sent\n            session.bytes_received += data_received\n            session.packets_sent += 1 if data_sent > 0 else 0\n            session.packets_received += 1 if data_received > 0 else 0\n            \n            return True\n    \n    def end_session(self, session_id: str, error: Optional[str] = None) -> bool:\n        """\n        End a TLS session.\n        \n        Args:\n            session_id: The session ID\n            error: Optional error message if the session ended abnormally\n            \n        Returns:\n            True if session was ended, False if not found\n        """\n        with self.lock:\n            session = self.sessions.get(session_id)\n            if not session:\n                return False\n                \n            session.end_time = time.time()\n            session.error = error\n            \n            # Log session summary\n            logger.info(\n                f"TLS session ended: {session_id} "\n                f"({session.src_ip}:{session.src_port} -> {session.dst_ip}:{session.dst_port}) "\n                f"Duration: {session.duration:.2f}s "\n                f"Sent: {session.bytes_sent} bytes, Received: {session.bytes_received} bytes"\n            )\n            \n            return True\n    \n    def get_session(self, session_id: str) -> Optional[TLSSession]:\n        """\n        Get a session by ID.\n        \n        Args:\n            session_id: The session ID\n            \n        Returns:\n            The session if found, None otherwise\n        """\n        with self.lock:\n            return self.sessions.get(session_id)\n    \n    def get_active_sessions(self) -> List[TLSSession]:\n        """\n        Get all active sessions.\n        \n        Returns:\n            List of active sessions\n        """\n        with self.lock:\n            return [s for s in self.sessions.values() if not s.end_time]\n    \n    def add_rule(self, rule: Dict[str, Any]) -> bool:\n        """\n        Add a custom rule to the inspection engine.\n        \n        Args:\n            rule: Rule dictionary with keys:\n                - name: Unique rule name\n                - description: Human-readable description\n                - condition: Callable that takes a TLSHandshake and returns a bool\n                - action: TLSAction to take if condition is True\n                - severity: Severity level (info, low, medium, high, critical)\n                - enabled: Whether the rule is enabled (default: True)\n                \n        Returns:\n            True if rule was added, False if a rule with that name already exists\n        """\n        required = {'name', 'description', 'condition', 'action'}\n        if not all(field in rule for field in required):\n            raise ValueError(f"Rule missing required fields: {required - set(rule.keys())}")\n            \n        with self.lock:\n            # Check for duplicate rule name\n            if any(r.get('name') == rule['name'] for r in self.rules):\n                return False\n                \n            # Set default values\n            rule.setdefault('enabled', True)\n            rule.setdefault('severity', 'medium')\n            \n            self.rules.append(rule)\n            return True\n    \n    def remove_rule(self, rule_name: str) -> bool:\n        """\n        Remove a rule by name.\n        \n        Args:\n            rule_name: Name of the rule to remove\n            \n        Returns:\n            True if rule was removed, False if not found\n        """\n        with self.lock:\n            for i, rule in enumerate(self.rules):\n                if rule.get('name') == rule_name:\n                    del self.rules[i]\n                    return True\n            return False\n    \n    def enable_rule(self, rule_name: str, enabled: bool = True) -> bool:\n        """\n        Enable or disable a rule.\n        \n        Args:\n            rule_name: Name of the rule to modify\n            enabled: Whether to enable or disable the rule\n            \n        Returns:\n            True if rule was found and updated, False otherwise\n        """\n        with self.lock:\n            for rule in self.rules:\n                if rule.get('name') == rule_name:\n                    rule['enabled'] = enabled\n                    return True\n            return False\n    \n    def get_rules(self) -> List[Dict[str, Any]]:\n        """\n        Get all rules.\n        \n        Returns:\n            List of rule dictionaries\n        """\n        with self.lock:\n            return [dict(r) for r in self.rules]\n\n# Example usage\nif __name__ == "__main__":\n    # Example configuration\n    config = {\n        'private_keys': ['/path/to/private.key'],  # For decryption\n        'ca_certificates': ['/path/to/ca.crt'],    # For certificate validation\n        'enable_mitm': True,                      # Enable MITM decryption if keys are available\n        'block_self_signed': True,                # Block self-signed certificates\n        'block_expired_certs': True,              # Block expired certificates\n        'block_weak_crypto': True,                # Block weak crypto\n        'min_tls_version': 'TLSv1.2',             # Minimum allowed TLS version\n    }\n    \n    # Create inspector\n    inspector = TLSInspector(config)\n    \n    # Example handshake (in a real system, this would come from packet capture)\n    handshake = TLSHandshake(\n        timestamp=time.time(),\n        src_ip='192.168.1.100',\n        src_port=54321,\n        dst_ip='93.184.216.34',  # example.com\n        dst_port=443,\n        server_name='example.com',\n        version='TLSv1.3',\n        cipher_suite='TLS_AES_256_GCM_SHA384',\n        certificate_chain=[],  # Would contain real certificates\n        alpn_protocols=['http/1.1']\n    )\n    \n    # Inspect the handshake\n    result = inspector.inspect_handshake(handshake)\n    print(f"Inspection result: {result}")\n    \n    # Start a new session\n    session_id = inspector.start_session(handshake)\n    print(f"Started session: {session_id}")\n    \n    # Update session with data transfer\n    inspector.update_session(session_id, data_sent=1024, data_received=2048)\n    \n    # End the session\n    inspector.end_session(session_id)\n    print(f"Session ended")
