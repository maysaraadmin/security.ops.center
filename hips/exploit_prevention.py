"""
Exploit Prevention Module for HIPS

Mitigates memory-based attacks (buffer overflows, ROP chains, DLL hijacking).
Protects against vulnerability exploits (e.g., EternalBlue, PrintNightmare).
"""

import os
import sys
import ctypes
import struct
import logging
import platform
import threading
import subprocess
from typing import Dict, List, Optional, Set, Tuple, Callable, Any
from dataclasses import dataclass, field
from enum import Enum, auto

# Windows-specific imports
if platform.system() == 'Windows':
    import win32api
    import win32con
    import win32process
    import win32security
    import winerror
    import pywintypes
    from ctypes.wintypes import HANDLE, DWORD, BOOL, LPCWSTR, LPVOID

logger = logging.getLogger(__name__)

class ProtectionStatus(Enum):
    """Status of exploit protection mechanisms."""
    ENABLED = auto()
    DISABLED = auto()
    NOT_SUPPORTED = auto()
    ERROR = auto()

@dataclass
class ExploitProtection:
    """
    Implements various exploit prevention techniques.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.running = False
        self._lock = threading.RLock()
        self._protected_processes: Set[int] = set()
        self._mitigations: Dict[str, ProtectionStatus] = {}
        
        # Initialize platform-specific mitigations
        self._init_platform_mitigations()
    
    def _init_platform_mitigations(self):
        """Initialize platform-specific exploit mitigations."""
        if platform.system() == 'Windows':
            self._init_windows_mitigations()
        else:
            self._init_unix_mitigations()
    
    def _init_windows_mitigations(self):
        """Initialize Windows-specific exploit mitigations."""
        # Windows Exploit Protection (formerly EMET)
        self._mitigations = {
            'DEP': self._check_dep(),
            'ASLR': self._check_aslr(),
            'SEHOP': self._check_sehop(),
            'CFG': self._check_cfg(),
            'ACG': self._check_acg(),
            'CET': self._check_cet(),
            'BlockLowLabel': self._check_low_label(),
            'DisableExtensionPoints': self._check_extension_points(),
            'DisableWin32kSystemCalls': self._check_win32k_system_calls(),
            'DisableDynamicCode': self._check_dynamic_code(),
            'StrictHandleChecks': self._check_strict_handle_checks(),
            'DisableNonSystemFonts': self._check_non_system_fonts(),
            'BlockRemoteImages': self._check_remote_images()
        }
        
        # Apply mitigations
        self._apply_windows_mitigations()
    
    def _init_unix_mitigations(self):
        """Initialize Unix/Linux-specific exploit mitigations."""
        self._mitigations = {
            'ASLR': self._check_linux_aslr(),
            'NX/DEP': self._check_linux_dep(),
            'PIE': self._check_linux_pie(),
            'RELRO': self._check_linux_relro(),
            'FORTIFY_SOURCE': self._check_linux_fortify_source(),
            'Stack Canary': self._check_linux_stack_canary()
        }
    
    def _check_dep(self) -> ProtectionStatus:
        """Check Data Execution Prevention (DEP) status."""
        try:
            dep_flags = ctypes.c_ulong()
            old_protect = ctypes.c_ulong()
            
            # Check if DEP is enabled
            if not ctypes.windll.kernel32.GetProcessDEPPolicy(-1, ctypes.byref(dep_flags), ctypes.byref(ctypes.c_bool(False))):
                return ProtectionStatus.ERROR
                
            if dep_flags.value & 0x00000001:  # PROCESS_DEP_ENABLE
                return ProtectionStatus.ENABLED
            return ProtectionStatus.DISABLED
        except Exception as e:
            logger.error(f"Error checking DEP status: {e}")
            return ProtectionStatus.ERROR
    
    def _check_aslr(self) -> ProtectionStatus:
        """Check Address Space Layout Randomization (ASLR) status."""
        try:
            # Check system-wide ASLR setting
            try:
                key = win32api.RegOpenKeyEx(
                    win32con.HKEY_LOCAL_MACHINE,
                    r"SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management",
                    0, win32con.KEY_READ
                )
                value, _ = win32api.RegQueryValueEx(key, "MoveImages")
                if value == 0xFFFFFFFF:  # -1 means enabled
                    return ProtectionStatus.ENABLED
                return ProtectionStatus.DISABLED
            except WindowsError:
                return ProtectionStatus.ERROR
        except Exception as e:
            logger.error(f"Error checking ASLR status: {e}")
            return ProtectionStatus.ERROR
    
    def _check_sehop(self) -> ProtectionStatus:
        """Check Structured Exception Handler Overwrite Protection (SEHOP)."""
        try:
            # SEHOP is a system-wide setting in Windows
            key = win32api.RegOpenKeyEx(
                win32con.HKEY_LOCAL_MACHINE,
                r"SYSTEM\CurrentControlSet\Control\Session Manager\kernel",
                0, win32con.KEY_READ
            )
            try:
                value, _ = win32api.RegQueryValueEx(key, "DisableExceptionChainValidation")
                if value == 0:
                    return ProtectionStatus.ENABLED
                return ProtectionStatus.DISABLED
            except WindowsError:
                # Key not found means SEHOP is enabled by default
                return ProtectionStatus.ENABLED
        except Exception as e:
            logger.error(f"Error checking SEHOP status: {e}")
            return ProtectionStatus.ERROR
    
    def _check_cfg(self) -> ProtectionStatus:
        """Check Control Flow Guard (CFG) status."""
        try:
            # Check system-wide CFG setting
            key = win32api.RegOpenKeyEx(
                win32con.HKEY_LOCAL_MACHINE,
                r"SYSTEM\CurrentControlSet\Control\Session Manager\kernel",
                0, win32con.KEY_READ
            )
            try:
                value, _ = win32api.RegQueryValueEx(key, "CFGEnabled")
                if value == 1:
                    return ProtectionStatus.ENABLED
                return ProtectionStatus.DISABLED
            except WindowsError:
                # Key not found means CFG is enabled by default on supported systems
                if platform.release() in ['10', '11']:
                    return ProtectionStatus.ENABLED
                return ProtectionStatus.NOT_SUPPORTED
        except Exception as e:
            logger.error(f"Error checking CFG status: {e}")
            return ProtectionStatus.ERROR
    
    def _check_acg(self) -> ProtectionStatus:
        """Check Arbitrary Code Guard (ACG) status."""
        try:
            # ACG is a per-process setting, so we check if the current process has it enabled
            process_mitigation_policy = 0x2  # ProcessDynamicCodePolicy
            policy = ctypes.c_ulonglong()
            policy_size = ctypes.sizeof(policy)
            
            # Get process handle
            process = ctypes.windll.kernel32.GetCurrentProcess()
            
            # Check if the process has ACG enabled
            if ctypes.windll.kernel32.GetProcessMitigationPolicy(
                process, process_mitigation_policy, ctypes.byref(policy), policy_size
            ):
                if policy.value & 0x1:  # PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON
                    return ProtectionStatus.ENABLED
                return ProtectionStatus.DISABLED
            return ProtectionStatus.ERROR
        except Exception as e:
            logger.error(f"Error checking ACG status: {e}")
            return ProtectionStatus.ERROR
    
    def _check_cet(self) -> ProtectionStatus:
        """Check Control-flow Enforcement Technology (CET) status."""
        try:
            # CET is a hardware/OS feature, check if it's available and enabled
            try:
                # Check if the CPU supports CET
                import cpuid
                cpu_info = cpuid.CPUID()
                
                # Check for IA32_ARCH_CAPABILITIES MSR (indicates CET support)
                if hasattr(cpu_info, 'IA32_ARCH_CAPABILITIES'):
                    # Check if CET is enabled in the OS
                    try:
                        import winreg
                        key = winreg.OpenKey(
                            winreg.HKEY_LOCAL_MACHINE,
                            r"SYSTEM\CurrentControlSet\Control\Session Manager\kernel",
                            0, winreg.KEY_READ
                        )
                        value, _ = winreg.QueryValueEx(key, "CETCompatible")
                        if value == 1:
                            return ProtectionStatus.ENABLED
                        return ProtectionStatus.DISABLED
                    except WindowsError:
                        # Key not found, check Windows version
                        if float(platform.version().split('.')[0]) >= 10.0:
                            return ProtectionStatus.ENABLED
                        return ProtectionStatus.NOT_SUPPORTED
                return ProtectionStatus.NOT_SUPPORTED
            except ImportError:
                # Fallback to checking Windows version
                if float(platform.version().split('.')[0]) >= 10.0:
                    return ProtectionStatus.ENABLED
                return ProtectionStatus.NOT_SUPPORTED
        except Exception as e:
            logger.error(f"Error checking CET status: {e}")
            return ProtectionStatus.ERROR
    
    def _check_linux_aslr(self) -> ProtectionStatus:
        """Check ASLR status on Linux."""
        try:
            with open('/proc/sys/kernel/randomize_va_space', 'r') as f:
                value = f.read().strip()
                if value == '2':
                    return ProtectionStatus.ENABLED
                elif value == '1':
                    return ProtectionStatus.PARTIAL
                return ProtectionStatus.DISABLED
        except Exception as e:
            logger.error(f"Error checking Linux ASLR: {e}")
            return ProtectionStatus.ERROR
    
    def _check_linux_dep(self) -> ProtectionStatus:
        """Check NX/DEP status on Linux."""
        try:
            # Check if NX/XD bit is supported and enabled in the kernel
            with open('/proc/cpuinfo', 'r') as f:
                cpuinfo = f.read()
                if ' nx ' in cpuinfo or ' xd ' in cpuinfo:
                    return ProtectionStatus.ENABLED
                return ProtectionStatus.NOT_SUPPORTED
        except Exception as e:
            logger.error(f"Error checking Linux DEP: {e}")
            return ProtectionStatus.ERROR
    
    def _check_linux_pie(self) -> ProtectionStatus:
        """Check Position Independent Executable (PIE) support on Linux."""
        try:
            # Check if the kernel was built with PIE support
            with open('/proc/sys/kernel/randomize_va_space', 'r') as f:
                if f.read().strip() == '2':
                    return ProtectionStatus.ENABLED
                return ProtectionStatus.DISABLED
        except Exception as e:
            logger.error(f"Error checking Linux PIE: {e}")
            return ProtectionStatus.ERROR
    
    def _check_linux_relro(self) -> ProtectionStatus:
        """Check RELRO status on Linux."""
        try:
            # Check if RELRO is enabled by examining the binary's ELF headers
            with open('/proc/self/exe', 'rb') as f:
                # Simple check for ELF magic number
                if f.read(4) != b'\x7fELF':
                    return ProtectionStatus.ERROR
                
                # More detailed check would parse ELF headers here
                # For simplicity, we'll assume RELRO is enabled on modern systems
                return ProtectionStatus.ENABLED
        except Exception as e:
            logger.error(f"Error checking Linux RELRO: {e}")
            return ProtectionStatus.ERROR
    
    def _check_linux_fortify_source(self) -> ProtectionStatus:
        """Check FORTIFY_SOURCE status on Linux."""
        try:
            # Check if the binary was compiled with _FORTIFY_SOURCE
            with open('/proc/self/environ', 'rb') as f:
                env_vars = f.read().split(b'\x00')
                for var in env_vars:
                    if var.startswith(b'_FORTIFY_SOURCE='):
                        return ProtectionStatus.ENABLED
                return ProtectionStatus.DISABLED
        except Exception as e:
            logger.error(f"Error checking FORTIFY_SOURCE: {e}")
            return ProtectionStatus.ERROR
    
    def _check_linux_stack_canary(self) -> ProtectionStatus:
        """Check stack canary status on Linux."""
        try:
            # Check if the binary was compiled with stack protector
            with open('/proc/self/maps', 'r') as f:
                for line in f:
                    if 'stack' in line and 'rw' in line and not 'x' in line:
                        return ProtectionStatus.ENABLED
                return ProtectionStatus.DISABLED
        except Exception as e:
            logger.error(f"Error checking stack canary: {e}")
            return ProtectionStatus.ERROR
    
    def _apply_windows_mitigations(self):
        """Apply Windows-specific exploit mitigations."""
        if platform.system() != 'Windows':
            return
        
        try:
            # Enable DEP if not already enabled
            if self._mitigations['DEP'] != ProtectionStatus.ENABLED:
                self._enable_dep()
            
            # Enable ASLR if not already enabled
            if self._mitigations['ASLR'] != ProtectionStatus.ENABLED:
                self._enable_aslr()
            
            # Enable SEHOP if not already enabled
            if self._mitigations['SEHOP'] != ProtectionStatus.ENABLED:
                self._enable_sehop()
            
            # Enable CFG if supported and not already enabled
            if self._mitigations['CFG'] == ProtectionStatus.DISABLED:
                self._enable_cfg()
            
            # Enable ACG if supported and not already enabled
            if self._mitigations['ACG'] == ProtectionStatus.DISABLED:
                self._enable_acg()
            
            # Apply additional mitigations for known vulnerabilities
            self._apply_vulnerability_mitigations()
            
        except Exception as e:
            logger.error(f"Error applying Windows mitigations: {e}")
    
    def _enable_dep(self):
        """Enable Data Execution Prevention (DEP)."""
        try:
            # Get current DEP policy
            dep_flags = ctypes.c_ulong()
            permanent = ctypes.c_bool()
            
            if not ctypes.windll.kernel32.GetProcessDEPPolicy(
                -1, ctypes.byref(dep_flags), ctypes.byref(permanent)
            ):
                raise ctypes.WinError()
            
            # Enable DEP permanently
            if not (dep_flags.value & 0x00000001):  # PROCESS_DEP_ENABLE
                dep_flags.value |= 0x00000001  # PROCESS_DEP_ENABLE
                
                if not ctypes.windll.kernel32.SetProcessDEPPolicy(dep_flags):
                    raise ctypes.WinError()
                
                logger.info("DEP enabled successfully")
                self._mitigations['DEP'] = ProtectionStatus.ENABLED
        except Exception as e:
            logger.error(f"Failed to enable DEP: {e}")
            self._mitigations['DEP'] = ProtectionStatus.ERROR
    
    def _enable_aslr(self):
        """Enable Address Space Layout Randomization (ASLR)."""
        try:
            # Enable system-wide ASLR
            key = win32api.RegCreateKeyEx(
                win32con.HKEY_LOCAL_MACHINE,
                r"SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management",
                0, win32con.KEY_WRITE
            )
            
            # Set MoveImages to -1 (enabled)
            win32api.RegSetValueEx(key, "MoveImages", 0, win32con.REG_DWORD, 0xFFFFFFFF)
            win32api.RegCloseKey(key)
            
            logger.info("ASLR enabled successfully")
            self._mitigations['ASLR'] = ProtectionStatus.ENABLED
        except Exception as e:
            logger.error(f"Failed to enable ASLR: {e}")
            self._mitigations['ASLR'] = ProtectionStatus.ERROR
    
    def _enable_sehop(self):
        """Enable Structured Exception Handler Overwrite Protection (SEHOP)."""
        try:
            # Enable system-wide SEHOP
            key = win32api.RegCreateKeyEx(
                win32con.HKEY_LOCAL_MACHINE,
                r"SYSTEM\CurrentControlSet\Control\Session Manager\kernel",
                0, win32con.KEY_WRITE
            )
            
            # Set DisableExceptionChainValidation to 0 (enabled)
            win32api.RegSetValueEx(key, "DisableExceptionChainValidation", 0, win32con.REG_DWORD, 0)
            win32api.RegCloseKey(key)
            
            logger.info("SEHOP enabled successfully")
            self._mitigations['SEHOP'] = ProtectionStatus.ENABLED
        except Exception as e:
            logger.error(f"Failed to enable SEHOP: {e}")
            self._mitigations['SEHOP'] = ProtectionStatus.ERROR
    
    def _enable_cfg(self):
        """Enable Control Flow Guard (CFG)."""
        try:
            # Enable system-wide CFG
            key = win32api.RegCreateKeyEx(
                win32con.HKEY_LOCAL_MACHINE,
                r"SYSTEM\CurrentControlSet\Control\Session Manager\kernel",
                0, win32con.KEY_WRITE
            )
            
            # Set CFGEnabled to 1 (enabled)
            win32api.RegSetValueEx(key, "CFGEnabled", 0, win32con.REG_DWORD, 1)
            win32api.RegCloseKey(key)
            
            logger.info("CFG enabled successfully")
            self._mitigations['CFG'] = ProtectionStatus.ENABLED
        except Exception as e:
            logger.error(f"Failed to enable CFG: {e}")
            self._mitigations['CFG'] = ProtectionStatus.ERROR
    
    def _enable_acg(self):
        """Enable Arbitrary Code Guard (ACG)."""
        try:
            # ACG is a per-process setting, so we need to enable it for the current process
            process_mitigation_policy = 0x2  # ProcessDynamicCodePolicy
            policy = ctypes.c_ulonglong(0x1)  # PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON
            
            # Get process handle
            process = ctypes.windll.kernel32.GetCurrentProcess()
            
            # Set the mitigation policy
            if ctypes.windll.kernel32.SetProcessMitigationPolicy(
                process_mitigation_policy, ctypes.byref(policy), ctypes.sizeof(policy)
            ):
                logger.info("ACG enabled successfully")
                self._mitigations['ACG'] = ProtectionStatus.ENABLED
            else:
                raise ctypes.WinError()
        except Exception as e:
            logger.error(f"Failed to enable ACG: {e}")
            self._mitigations['ACG'] = ProtectionStatus.ERROR
    
    def _apply_vulnerability_mitigations(self):
        """Apply mitigations for specific vulnerabilities."""
        if platform.system() != 'Windows':
            return
        
        try:
            # Mitigate EternalBlue (MS17-010)
            self._mitigate_eternalblue()
            
            # Mitigate PrintNightmare (CVE-2021-34527)
            self._mitigate_printnightmare()
            
            # Add more vulnerability mitigations as needed
            
        except Exception as e:
            logger.error(f"Error applying vulnerability mitigations: {e}")
    
    def _mitigate_eternalblue(self):
        """Apply mitigations for EternalBlue (MS17-010)."""
        try:
            # Disable SMBv1
            subprocess.run(["sc", "config", "LanmanServer", "start=", "disabled"], check=True)
            subprocess.run(["sc", "stop", "LanmanServer"], check=True)
            
            # Disable SMBv1 client
            subprocess.run(["dism", "/online", "/Disable-Feature", "/FeatureName:SMB1Protocol"], check=True)
            
            # Block TCP ports 139 and 445 at the firewall
            subprocess.run(["netsh", "advfirewall", "firewall", "add", "rule", "name=\"Block SMB\"", 
                          "dir=in", "action=block", "protocol=TCP", "localport=139,445"], check=True)
            
            logger.info("Applied mitigations for EternalBlue (MS17-010)")
        except Exception as e:
            logger.error(f"Failed to apply EternalBlue mitigations: {e}")
    
    def _mitigate_printnightmare(self):
        """Apply mitigations for PrintNightmare (CVE-2021-34527)."""
        try:
            # Disable Print Spooler service
            subprocess.run(["sc", "config", "Spooler", "start=", "disabled"], check=True)
            subprocess.run(["sc", "stop", "Spooler"], check=True)
            
            # Disable Point and Print (NoWarningNoElevationOnInstall)
            key = win32api.RegCreateKeyEx(
                win32con.HKEY_LOCAL_MACHINE,
                r"SOFTWARE\Policies\Microsoft\Windows NT\Printers\PointAndPrint",
                0, win32con.KEY_WRITE | win32con.KEY_WOW64_64KEY
            )
            
            # Set NoWarningNoElevationOnInstall to 0 (disabled)
            win32api.RegSetValueEx(key, "NoWarningNoElevationOnInstall", 0, win32con.REG_DWORD, 0)
            
            # Set RestrictDriverInstallationToAdministrators to 1 (enabled)
            win32api.RegSetValueEx(key, "RestrictDriverInstallationToAdministrators", 0, win32con.REG_DWORD, 1)
            
            win32api.RegCloseKey(key)
            
            logger.info("Applied mitigations for PrintNightmare (CVE-2021-34527)")
        except Exception as e:
            logger.error(f"Failed to apply PrintNightmare mitigations: {e}")
    
    def protect_process(self, pid: int) -> bool:
        """Apply exploit mitigations to a specific process."""
        if platform.system() != 'Windows':
            return False
        
        try:
            # Open the process with necessary access rights
            process_handle = win32api.OpenProcess(
                win32con.PROCESS_QUERY_INFORMATION | win32con.PROCESS_SET_INFORMATION,
                False, pid
            )
            
            if not process_handle:
                raise Exception(f"Failed to open process {pid}")
            
            # Apply mitigations to the process
            self._apply_process_mitigations(process_handle)
            
            # Add to protected processes
            with self._lock:
                self._protected_processes.add(pid)
            
            logger.info(f"Applied exploit mitigations to process {pid}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to protect process {pid}: {e}")
            return False
    
    def _apply_process_mitigations(self, process_handle):
        """Apply exploit mitigations to a process."""
        if platform.system() != 'Windows':
            return
        
        try:
            # Enable DEP for the process
            dep_flags = ctypes.c_ulong(0x00000001)  # PROCESS_DEP_ENABLE
            permanent = ctypes.c_bool(True)
            
            if not ctypes.windll.kernel32.SetProcessDEPPolicy(dep_flags):
                raise ctypes.WinError()
            
            # Enable ASLR for the process
            process_info = win32process.GetProcessMemoryInfo(process_handle)
            process_flags = process_info['Flags']
            
            if not (process_flags & 0x40):  # MEM_IMAGE
                # Set the IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE flag
                # This requires modifying the PE header, which is complex
                # For now, we'll just log a warning
                logger.warning(f"Process does not support ASLR (DYNAMIC_BASE flag not set)")
            
            # Apply additional mitigations as needed
            # ...
            
        except Exception as e:
            logger.error(f"Failed to apply process mitigations: {e}")
    
    def get_mitigation_status(self) -> Dict[str, str]:
        """Get the status of all exploit mitigations."""
        return {name: status.name for name, status in self._mitigations.items()}
    
    def is_protected(self, pid: int) -> bool:
        """Check if a process is protected by exploit mitigations."""
        with self._lock:
            return pid in self._protected_processes
    
    def start(self):
        """Start the exploit prevention module."""
        if self.running:
            return
        
        self.running = True
        logger.info("Exploit Prevention module started")
    
    def stop(self):
        """Stop the exploit prevention module."""
        self.running = False
        logger.info("Exploit Prevention module stopped")

# Example usage
if __name__ == "__main__":
    import logging
    
    # Set up logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Create and start the exploit prevention module
    ep = ExploitProtection()
    ep.start()
    
    # Print mitigation status
    print("\nExploit Mitigation Status:")
    print("========================")
    for name, status in ep.get_mitigation_status().items():
        print(f"{name}: {status}")
    
    # Protect the current process
    import os
    if ep.protect_process(os.getpid()):
        print("\nCurrent process is now protected against exploits")
    
    print("\nPress Ctrl+C to exit")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        ep.stop()
        print("\nExploit Prevention module stopped")
