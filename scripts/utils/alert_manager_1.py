"""
Alert Manager for SIEM

This module handles the management, deduplication, and notification of security alerts
generated by the SIEM system.
"""

import json
import logging
import time
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set, Callable, Any, Tuple
from dataclasses import dataclass, field, asdict
from enum import Enum, auto
import threading
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import requests

# Configure logging
logger = logging.getLogger('siem.alert_manager')

class AlertSeverity(Enum):
    """Standard severity levels for security alerts."""
    INFO = auto()
    LOW = auto()
    MEDIUM = auto()
    HIGH = auto()
    CRITICAL = auto()

class AlertStatus(Enum):
    """Possible status values for an alert."""
    NEW = "new"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    DISMISSED = "dismissed"
    ESCALATED = "escalated"

@dataclass
class Alert:
    """Represents a security alert in the SIEM system."""
    id: str
    title: str
    description: str
    severity: AlertSeverity
    status: AlertStatus = AlertStatus.NEW
    source: str = "siem"
    timestamp: datetime = field(default_factory=datetime.utcnow)
    last_updated: datetime = field(default_factory=datetime.utcnow)
    source_events: List[Dict] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    assigned_to: Optional[str] = None
    resolution: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the alert to a dictionary for serialization."""
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'severity': self.severity.name,
            'status': self.status.value,
            'source': self.source,
            'timestamp': self.timestamp.isoformat(),
            'last_updated': self.last_updated.isoformat(),
            'source_events': self.source_events,
            'metadata': self.metadata,
            'assigned_to': self.assigned_to,
            'resolution': self.resolution,
            'tags': self.tags
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Alert':
        """Create an alert from a dictionary."""
        return cls(
            id=data['id'],
            title=data['title'],
            description=data['description'],
            severity=AlertSeverity[data['severity']],
            status=AlertStatus(data['status']),
            source=data.get('source', 'siem'),
            timestamp=datetime.fromisoformat(data['timestamp']),
            last_updated=datetime.fromisoformat(data.get('last_updated', data['timestamp'])),
            source_events=data.get('source_events', []),
            metadata=data.get('metadata', {}),
            assigned_to=data.get('assigned_to'),
            resolution=data.get('resolution'),
            tags=data.get('tags', [])
        )
    
    def update(self, **kwargs) -> None:
        """Update alert fields and set last_updated timestamp."""
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)
        self.last_updated = datetime.utcnow()
    
    def add_event(self, event: Dict) -> None:
        """Add a source event to this alert."""
        self.source_events.append(event)
        self.last_updated = datetime.utcnow()
    
    def calculate_fingerprint(self) -> str:
        """Calculate a fingerprint for deduplication."""
        # Create a stable string representation of the alert's identifying features
        fingerprint_data = {
            'title': self.title,
            'source': self.source,
            'severity': self.severity.name,
            'tags': sorted(self.tags) if self.tags else [],
            # Include any identifying metadata for deduplication
            'identifiers': {
                k: v for k, v in self.metadata.items()
                if k in ['source_ip', 'destination_ip', 'user', 'process']
            }
        }
        
        # Convert to JSON and hash it
        fingerprint_str = json.dumps(fingerprint_data, sort_keys=True)
        return hashlib.sha256(fingerprint_str.encode('utf-8')).hexdigest()

class NotificationTarget:
    """Base class for alert notification targets."""
    
    def send(self, alert: Alert, message: Optional[str] = None) -> bool:
        """Send an alert notification.
        
        Args:
            alert: The alert to send
            message: Optional custom message
            
        Returns:
            bool: True if the notification was sent successfully
        """
        raise NotImplementedError("Subclasses must implement send()")

class EmailNotification(NotificationTarget):
    """Send alerts via email."""
    
    def __init__(self, smtp_server: str, smtp_port: int, username: str, 
                 password: str, from_addr: str, to_addrs: List[str], 
                 use_tls: bool = True):
        """Initialize the email notification target.
        
        Args:
            smtp_server: SMTP server hostname
            smtp_port: SMTP server port
            username: SMTP username
            password: SMTP password
            from_addr: Sender email address
            to_addrs: List of recipient email addresses
            use_tls: Whether to use TLS for the SMTP connection
        """
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.username = username
        self.password = password
        self.from_addr = from_addr
        self.to_addrs = to_addrs
        self.use_tls = use_tls
    
    def send(self, alert: Alert, message: Optional[str] = None) -> bool:
        """Send an alert via email."""
        try:
            # Create message
            msg = MIMEMultipart()
            msg['From'] = self.from_addr
            msg['To'] = ', '.join(self.to_addrs)
            msg['Subject'] = f"[{alert.severity.name}] {alert.title}"
            
            # Create email body
            body = f"""
            Alert: {alert.title}
            Severity: {alert.severity.name}
            Status: {alert.status.value}
            Time: {alert.timestamp.isoformat()}
            
            Description:
            {alert.description}
            
            {message or ''}
            
            ---
            This is an automated message from the SIEM system.
            """
            
            msg.attach(MIMEText(body.strip(), 'plain'))
            
            # Connect to SMTP server and send
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                if self.use_tls:
                    server.starttls()
                if self.username and self.password:
                    server.login(self.username, self.password)
                server.send_message(msg)
            
            logger.info(f"Sent email alert: {alert.id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to send email alert: {e}")
            return False

class SlackNotification(NotificationTarget):
    """Send alerts to Slack."""
    
    def __init__(self, webhook_url: str, channel: Optional[str] = None, 
                 username: str = "SIEM Bot", icon_emoji: str = ":warning:"):
        """Initialize the Slack notification target.
        
        Args:
            webhook_url: Incoming webhook URL
            channel: Optional channel to override the webhook's default
            username: Display name for the bot
            icon_emoji: Emoji to use as the bot's icon
        """
        self.webhook_url = webhook_url
        self.channel = channel
        self.username = username
        self.icon_emoji = icon_emoji
    
    def send(self, alert: Alert, message: Optional[str] = None) -> bool:
        """Send an alert to Slack."""
        try:
            # Map severity to Slack message formatting
            severity_colors = {
                AlertSeverity.INFO: "#36a64f",    # Green
                AlertSeverity.LOW: "#2eb886",     # Light green
                AlertSeverity.MEDIUM: "#e6a23c",  # Yellow
                AlertSeverity.HIGH: "#e6a23c",    # Orange
                AlertSeverity.CRITICAL: "#e74c3c" # Red
            }
            
            # Create Slack message payload
            payload = {
                'username': self.username,
                'icon_emoji': self.icon_emoji,
                'attachments': [{
                    'fallback': f"[{alert.severity.name}] {alert.title}",
                    'color': severity_colors.get(alert.severity, '#36a64f'),
                    'title': alert.title,
                    'text': alert.description,
                    'fields': [
                        {
                            'title': 'Severity',
                            'value': alert.severity.name,
                            'short': True
                        },
                        {
                            'title': 'Status',
                            'value': alert.status.value.title(),
                            'short': True
                        },
                        {
                            'title': 'Time',
                            'value': alert.timestamp.strftime('%Y-%m-%d %H:%M:%S UTC'),
                            'short': True
                        },
                        {
                            'title': 'Source',
                            'value': alert.source,
                            'short': True
                        }
                    ]
                }]
            }
            
            if self.channel:
                payload['channel'] = self.channel
            
            if message:
                payload['attachments'][0]['text'] += f"\n\n{message}"
            
            # Add tags if present
            if alert.tags:
                payload['attachments'][0]['fields'].append({
                    'title': 'Tags',
                    'value': ', '.join(alert.tags),
                    'short': False
                })
            
            # Send to Slack
            response = requests.post(
                self.webhook_url,
                json=payload,
                headers={'Content-Type': 'application/json'}
            )
            
            if response.status_code == 200:
                logger.info(f"Sent Slack alert: {alert.id}")
                return True
            else:
                logger.error(f"Failed to send Slack alert: {response.status_code} {response.text}")
                return False
                
        except Exception as e:
            logger.error(f"Error sending Slack alert: {e}")
            return False

class AlertManager:
    """
    Manages security alerts, including deduplication, notification, and escalation.
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """Initialize the alert manager.
        
        Args:
            config: Configuration dictionary
        """
        self.config = config or {}
        self.alerts: Dict[str, Alert] = {}
        self.alert_history: Dict[str, List[Tuple[datetime, str]]] = {}
        self.notification_targets: List[NotificationTarget] = []
        self.callbacks: List[Callable[[Alert], None]] = []
        self.deduplication_window = timedelta(hours=24)  # Default deduplication window
        self.running = False
        self.lock = threading.Lock()
        
        # Load configuration
        self._load_config()
    
    def _load_config(self) -> None:
        """Load configuration from the provided config dictionary."""
        # Set deduplication window from config or use default
        self.deduplication_window = timedelta(
            seconds=self.config.get('deduplication_window_seconds', 24 * 3600)
        )
        
        # Set up notification targets
        if 'notifications' in self.config:
            if 'email' in self.config['notifications'] and self.config['notifications']['email'].get('enabled', False):
                email_cfg = self.config['notifications']['email']
                self.add_notification_target(EmailNotification(
                    smtp_server=email_cfg['smtp_server'],
                    smtp_port=email_cfg.get('smtp_port', 587),
                    username=email_cfg.get('username', ''),
                    password=email_cfg.get('password', ''),
                    from_addr=email_cfg['from_address'],
                    to_addrs=email_cfg['to_addresses'],
                    use_tls=email_cfg.get('use_tls', True)
                ))
            
            if 'slack' in self.config['notifications'] and self.config['notifications']['slack'].get('enabled', False):
                slack_cfg = self.config['notifications']['slack']
                self.add_notification_target(SlackNotification(
                    webhook_url=slack_cfg['webhook_url'],
                    channel=slack_cfg.get('channel'),
                    username=slack_cfg.get('username', 'SIEM Bot'),
                    icon_emoji=slack_cfg.get('icon_emoji', ':warning:')
                ))
    
    def start(self) -> None:
        """Start the alert manager."""
        if not self.running:
            self.running = True
            logger.info("Alert manager started")
    
    def stop(self) -> None:
        """Stop the alert manager."""
        if self.running:
            self.running = False
            logger.info("Alert manager stopped")
    
    def add_notification_target(self, target: NotificationTarget) -> None:
        """Add a notification target for alerts.
        
        Args:
            target: Notification target to add
        """
        if target not in self.notification_targets:
            self.notification_targets.append(target)
    
    def add_callback(self, callback: Callable[[Alert], None]) -> None:
        """Add a callback function to be called when a new alert is created.
        
        Args:
            callback: Function that takes an Alert object
        """
        if callable(callback) and callback not in self.callbacks:
            self.callbacks.append(callback)
    
    def create_alert(self, title: str, description: str, severity: AlertSeverity,
                    source: str = "siem", source_events: Optional[List[Dict]] = None,
                    metadata: Optional[Dict] = None, tags: Optional[List[str]] = None) -> Alert:
        """Create and store a new alert.
        
        Args:
            title: Alert title
            description: Detailed description of the alert
            severity: Alert severity level
            source: Source of the alert (e.g., 'edr', 'ids', 'correlation')
            source_events: List of source events that triggered this alert
            metadata: Additional metadata about the alert
            tags: List of tags for categorization
            
        Returns:
            The created Alert object
        """
        alert_id = hashlib.sha256(
            f"{title}:{description}:{source}:{time.time()}".encode()
        ).hexdigest()
        
        alert = Alert(
            id=alert_id,
            title=title,
            description=description,
            severity=severity,
            source=source,
            source_events=source_events or [],
            metadata=metadata or {},
            tags=tags or []
        )
        
        # Check for duplicates before adding
        fingerprint = alert.calculate_fingerprint()
        duplicate_alert_id = self._find_duplicate_alert(fingerprint)
        
        with self.lock:
            if duplicate_alert_id:
                # Update existing alert
                existing_alert = self.alerts[duplicate_alert_id]
                existing_alert.update(
                    last_updated=datetime.utcnow(),
                    status=AlertStatus.NEW
                )
                
                # Add source events if provided
                if source_events:
                    for event in source_events:
                        existing_alert.add_event(event)
                
                logger.info(f"Updated existing alert: {duplicate_alert_id}")
                return existing_alert
            else:
                # Add new alert
                self.alerts[alert_id] = alert
                
                # Store fingerprint for deduplication
                if fingerprint not in self.alert_history:
                    self.alert_history[fingerprint] = []
                self.alert_history[fingerprint].append((alert.timestamp, alert_id))
                
                # Notify callbacks
                for callback in self.callbacks:
                    try:
                        callback(alert)
                    except Exception as e:
                        logger.error(f"Error in alert callback: {e}")
                
                # Send notifications
                self._notify(alert)
                
                logger.info(f"Created new alert: {alert_id} - {title}")
                return alert
    
    def _find_duplicate_alert(self, fingerprint: str) -> Optional[str]:
        """Find a duplicate alert based on fingerprint and deduplication window.
        
        Args:
            fingerprint: Alert fingerprint to check
            
        Returns:
            ID of a duplicate alert if found, None otherwise
        """
        now = datetime.utcnow()
        
        if fingerprint in self.alert_history:
            # Check for recent alerts with the same fingerprint
            for timestamp, alert_id in self.alert_history[fingerprint]:
                if now - timestamp <= self.deduplication_window:
                    return alert_id
        
        return None
    
    def _notify(self, alert: Alert) -> None:
        """Send notifications for an alert to all configured targets.
        
        Args:
            alert: The alert to notify about
        """
        if not self.notification_targets:
            return
        
        # Only send notifications for medium severity and above by default
        if alert.severity.value < AlertSeverity.MEDIUM.value:
            return
        
        for target in self.notification_targets:
            try:
                target.send(alert)
            except Exception as e:
                logger.error(f"Error sending notification via {target.__class__.__name__}: {e}")
    
    def get_alert(self, alert_id: str) -> Optional[Alert]:
        """Retrieve an alert by ID.
        
        Args:
            alert_id: ID of the alert to retrieve
            
        Returns:
            The requested Alert, or None if not found
        """
        return self.alerts.get(alert_id)
    
    def update_alert_status(self, alert_id: str, status: AlertStatus, 
                          assigned_to: Optional[str] = None, 
                          resolution: Optional[str] = None) -> bool:
        """Update the status of an alert.
        
        Args:
            alert_id: ID of the alert to update
            status: New status
            assigned_to: Optional user to assign the alert to
            resolution: Optional resolution details
            
        Returns:
            bool: True if the update was successful, False otherwise
        """
        if alert_id not in self.alerts:
            return False
        
        with self.lock:
            alert = self.alerts[alert_id]
            update_data = {'status': status}
            
            if assigned_to is not None:
                update_data['assigned_to'] = assigned_to
            if resolution is not None:
                update_data['resolution'] = resolution
            
            alert.update(**update_data)
            logger.info(f"Updated alert {alert_id} status to {status.value}")
            
            # Notify about status change
            self._notify(alert)
            
            return True
    
    def get_alerts(self, status: Optional[AlertStatus] = None, 
                  severity: Optional[AlertSeverity] = None,
                  source: Optional[str] = None, 
                  limit: int = 100) -> List[Alert]:
        """Retrieve alerts matching the specified filters.
        
        Args:
            status: Filter by status
            severity: Filter by severity
            source: Filter by source
            limit: Maximum number of alerts to return
            
        Returns:
            List of matching alerts, sorted by timestamp (newest first)
        """
        filtered = []
        
        for alert in self.alerts.values():
            if status is not None and alert.status != status:
                continue
            if severity is not None and alert.severity != severity:
                continue
            if source is not None and alert.source != source:
                continue
            
            filtered.append(alert)
        
        # Sort by timestamp (newest first)
        filtered.sort(key=lambda x: x.timestamp, reverse=True)
        
        return filtered[:limit]
    
    def cleanup_old_alerts(self, max_age_days: int = 30) -> None:
        """Remove alerts older than the specified number of days.
        
        Args:
            max_age_days: Maximum age in days to keep alerts
        """
        cutoff = datetime.utcnow() - timedelta(days=max_age_days)
        removed = 0
        
        with self.lock:
            # Find and remove old alerts
            for alert_id in list(self.alerts.keys()):
                if self.alerts[alert_id].timestamp < cutoff:
                    del self.alerts[alert_id]
                    removed += 1
            
            # Clean up alert history
            for fingerprint in list(self.alert_history.keys()):
                # Keep only recent entries
                recent = [
                    (ts, alert_id) 
                    for ts, alert_id in self.alert_history[fingerprint]
                    if ts > cutoff
                ]
                
                if recent:
                    self.alert_history[fingerprint] = recent
                else:
                    del self.alert_history[fingerprint]
        
        if removed > 0:
            logger.info(f"Cleaned up {removed} alerts older than {max_age_days} days")
