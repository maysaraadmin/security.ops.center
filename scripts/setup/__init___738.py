"""
SIEM Correlation Engine

This module provides a rules-based correlation engine for detecting security events
and generating alerts based on log data.
"""
from typing import Dict, List, Any, Optional, Callable
import yaml
import re
import json
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
import logging

# Configure logging
logger = logging.getLogger('siem.correlation_engine')

class Severity(Enum):
    """Severity levels for correlation rules and alerts"""
    INFO = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

@dataclass
class Alert:
    """Represents a security alert generated by the correlation engine"""
    id: str
    title: str
    description: str
    severity: Severity
    timestamp: datetime
    source: str
    details: Dict[str, Any] = field(default_factory=dict)
    related_events: List[Dict[str, Any]] = field(default_factory=list)
    status: str = 'open'
    assigned_to: Optional[str] = None
    comments: List[Dict[str, str]] = field(default_factory=list)

class Rule:
    """Base class for correlation rules"""
    
    def __init__(self, rule_id: str, name: str, description: str, 
                 severity: Severity, enabled: bool = True):
        self.id = rule_id
        self.name = name
        self.description = description
        self.severity = severity
        self.enabled = enabled
        self.logger = logging.getLogger(f'siem.correlation_engine.rule.{rule_id}')
    
    def match(self, event: Dict[str, Any]) -> Optional[Alert]:
        """Check if the rule matches the given event"""
        raise NotImplementedError("Subclasses must implement match()")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert rule to dictionary for serialization"""
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'severity': self.severity.name,
            'enabled': self.enabled,
            'type': self.__class__.__name__
        }

class SimpleRule(Rule):
    """A rule that matches a single event based on field patterns"""
    
    def __init__(self, rule_id: str, name: str, description: str, 
                 severity: Severity, patterns: Dict[str, str], 
                 enabled: bool = True):
        super().__init__(rule_id, name, description, severity, enabled)
        self.patterns = patterns
        self.compiled_patterns = {
            field: re.compile(pattern) 
            for field, pattern in patterns.items()
        }
    
    def match(self, event: Dict[str, Any]) -> Optional[Alert]:
        if not self.enabled:
            return None
            
        for field, pattern in self.compiled_patterns.items():
            if field not in event:
                return None
                
            if not pattern.search(str(event[field])):
                return None
        
        # All patterns matched
        return Alert(
            id=f"alert_{self.id}_{int(datetime.utcnow().timestamp())}",
            title=f"Rule triggered: {self.name}",
            description=self.description,
            severity=self.severity,
            timestamp=datetime.utcnow(),
            source=self.id,
            details={
                'event': event,
                'matched_patterns': self.patterns
            },
            related_events=[event]
        )
    
    def to_dict(self) -> Dict[str, Any]:
        result = super().to_dict()
        result['patterns'] = self.patterns
        return result

class ThresholdRule(Rule):
    """A rule that triggers when a threshold is exceeded within a time window"""
    
    def __init__(self, rule_id: str, name: str, description: str, 
                 severity: Severity, field: str, threshold: int, 
                 time_window: int, group_by: Optional[List[str]] = None,
                 enabled: bool = True):
        super().__init__(rule_id, name, description, severity, enabled)
        self.field = field
        self.threshold = threshold
        self.time_window = timedelta(seconds=time_window)
        self.group_by = group_by or []
        self.counts = {}  # (group_key) -> List[(timestamp, count)]
    
    def _get_group_key(self, event: Dict[str, Any]) -> str:
        """Generate a key for grouping events"""
        if not self.group_by:
            return 'all'
        
        key_parts = []
        for field in self.group_by:
            value = event.get(field, 'unknown')
            key_parts.append(f"{field}={value}")
        
        return '|'.join(key_parts)
    
    def _cleanup_old_entries(self, current_time: datetime):
        """Remove entries older than the time window"""
        cutoff = current_time - self.time_window
        for key in list(self.counts.keys()):
            # Keep only entries within the time window
            self.counts[key] = [
                (ts, count) for ts, count in self.counts[key] 
                if ts >= cutoff
            ]
            
            # Remove empty groups
            if not self.counts[key]:
                del self.counts[key]
    
    def match(self, event: Dict[str, Any]) -> Optional[Alert]:
        if not self.enabled or self.field not in event:
            return None
        
        current_time = datetime.utcnow()
        group_key = self._get_group_key(event)
        
        # Initialize group if it doesn't exist
        if group_key not in self.counts:
            self.counts[group_key] = []
        
        # Add current event
        self.counts[group_key].append((current_time, 1))
        
        # Clean up old entries
        self._cleanup_old_entries(current_time)
        
        # Calculate total count for this group
        total = sum(count for _, count in self.counts[group_key])
        
        if total >= self.threshold:
            # Reset count after alert
            self.counts[group_key] = []
            
            # Generate alert details
            details = {
                'field': self.field,
                'threshold': self.threshold,
                'time_window_seconds': self.time_window.total_seconds(),
                'current_count': total,
                'group_key': group_key,
                'event': event
            }
            
            return Alert(
                id=f"alert_{self.id}_{int(current_time.timestamp())}",
                title=f"Threshold exceeded: {self.name}",
                description=f"{self.description}\nCount: {total} (threshold: {self.threshold})",
                severity=self.severity,
                timestamp=current_time,
                source=self.id,
                details=details,
                related_events=[event]
            )
        
        return None
    
    def to_dict(self) -> Dict[str, Any]:
        result = super().to_dict()
        result.update({
            'field': self.field,
            'threshold': self.threshold,
            'time_window_seconds': self.time_window.total_seconds(),
            'group_by': self.group_by
        })
        return result

class CorrelationEngine:
    """Main correlation engine that manages rules and processes events"""
    
    def __init__(self, rules_file: Optional[str] = None):
        self.rules: Dict[str, Rule] = {}
        self.logger = logging.getLogger('siem.correlation_engine')
        self.alerts: List[Alert] = []
        self.alert_callbacks: List[Callable[[Alert], None]] = []
        
        if rules_file:
            self.load_rules_from_file(rules_file)
    
    def add_rule(self, rule: Rule) -> bool:
        """Add a rule to the engine"""
        if rule.id in self.rules:
            self.logger.warning(f"Rule with ID {rule.id} already exists")
            return False
        
        self.rules[rule.id] = rule
        self.logger.info(f"Added rule: {rule.name} (ID: {rule.id})")
        return True
    
    def remove_rule(self, rule_id: str) -> bool:
        """Remove a rule from the engine"""
        if rule_id not in self.rules:
            self.logger.warning(f"Rule with ID {rule_id} not found")
            return False
        
        del self.rules[rule_id]
        self.logger.info(f"Removed rule: {rule_id}")
        return True
    
    def enable_rule(self, rule_id: str) -> bool:
        """Enable a rule"""
        if rule_id not in self.rules:
            self.logger.warning(f"Rule with ID {rule_id} not found")
            return False
        
        self.rules[rule_id].enabled = True
        self.logger.info(f"Enabled rule: {rule_id}")
        return True
    
    def disable_rule(self, rule_id: str) -> bool:
        """Disable a rule"""
        if rule_id not in self.rules:
            self.logger.warning(f"Rule with ID {rule_id} not found")
            return False
        
        self.rules[rule_id].enabled = False
        self.logger.info(f"Disabled rule: {rule_id}")
        return True
    
    def process_event(self, event: Dict[str, Any]) -> List[Alert]:
        """Process an event through all rules and return any generated alerts"""
        alerts = []
        
        for rule in self.rules.values():
            try:
                alert = rule.match(event)
                if alert:
                    alerts.append(alert)
                    self.alerts.append(alert)
                    self._notify_alert(alert)
            except Exception as e:
                self.logger.error(f"Error processing event with rule {rule.id}: {str(e)}")
                continue
        
        return alerts
    
    def register_alert_callback(self, callback: Callable[[Alert], None]) -> None:
        """Register a callback to be called when a new alert is generated"""
        self.alert_callbacks.append(callback)
    
    def _notify_alert(self, alert: Alert) -> None:
        """Notify all registered callbacks about a new alert"""
        for callback in self.alert_callbacks:
            try:
                callback(alert)
            except Exception as e:
                self.logger.error(f"Error in alert callback: {str(e)}")
    
    def get_alerts(self, limit: int = 100) -> List[Dict[str, Any]]:
        """Get recent alerts"""
        return [
            {
                'id': alert.id,
                'title': alert.title,
                'description': alert.description,
                'severity': alert.severity.name,
                'timestamp': alert.timestamp.isoformat(),
                'source': alert.source,
                'status': alert.status,
                'assigned_to': alert.assigned_to
            }
            for alert in sorted(
                self.alerts, 
                key=lambda x: x.timestamp, 
                reverse=True
            )[:limit]
        ]
    
    def get_rule(self, rule_id: str) -> Optional[Dict[str, Any]]:
        """Get a rule by ID"""
        rule = self.rules.get(rule_id)
        return rule.to_dict() if rule else None
    
    def get_rules(self) -> List[Dict[str, Any]]:
        """Get all rules"""
        return [rule.to_dict() for rule in self.rules.values()]
    
    def load_rules_from_file(self, file_path: str) -> bool:
        """Load rules from a YAML file"""
        try:
            with open(file_path, 'r') as f:
                rules_config = yaml.safe_load(f)
            
            for rule_config in rules_config.get('rules', []):
                self._create_rule_from_config(rule_config)
            
            self.logger.info(f"Loaded {len(self.rules)} rules from {file_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error loading rules from {file_path}: {str(e)}")
            return False
    
    def _create_rule_from_config(self, config: Dict[str, Any]) -> Optional[Rule]:
        """Create a rule from a configuration dictionary"""
        try:
            rule_type = config.get('type', 'simple')
            rule_id = config['id']
            name = config['name']
            description = config.get('description', '')
            severity = Severity[config.get('severity', 'MEDIUM').upper()]
            enabled = config.get('enabled', True)
            
            if rule_type == 'simple':
                return SimpleRule(
                    rule_id=rule_id,
                    name=name,
                    description=description,
                    severity=severity,
                    patterns=config['patterns'],
                    enabled=enabled
                )
            elif rule_type == 'threshold':
                return ThresholdRule(
                    rule_id=rule_id,
                    name=name,
                    description=description,
                    severity=severity,
                    field=config['field'],
                    threshold=config['threshold'],
                    time_window=config.get('time_window_seconds', 300),
                    group_by=config.get('group_by', []),
                    enabled=enabled
                )
            else:
                self.logger.warning(f"Unknown rule type: {rule_type}")
                return None
                
        except KeyError as e:
            self.logger.error(f"Invalid rule configuration, missing key: {str(e)}")
            return None
        except Exception as e:
            self.logger.error(f"Error creating rule: {str(e)}")
            return None

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)
    
    # Create correlation engine
    engine = CorrelationEngine()
    
    # Add a simple rule
    simple_rule = SimpleRule(
        rule_id="ssh_failed_login",
        name="Failed SSH Login",
        description="Detect failed SSH login attempts",
        severity=Severity.MEDIUM,
        patterns={
            "event_type": "authentication_failure",
            "service": "ssh"
        }
    )
    engine.add_rule(simple_rule)
    
    # Add a threshold rule
    threshold_rule = ThresholdRule(
        rule_id="brute_force_attempt",
        name="Brute Force Attempt",
        description="Multiple failed login attempts from the same source",
        severity=Severity.HIGH,
        field="source_ip",
        threshold=5,
        time_window=300,  # 5 minutes
        group_by=["source_ip", "username"]
    )
    engine.add_rule(threshold_rule)
    
    # Process some example events
    events = [
        {"event_type": "authentication_failure", "service": "ssh", "source_ip": "192.168.1.1", "username": "admin"},
        {"event_type": "authentication_failure", "service": "ssh", "source_ip": "192.168.1.1", "username": "admin"},
        {"event_type": "authentication_failure", "service": "ssh", "source_ip": "192.168.1.1", "username": "admin"},
        {"event_type": "authentication_success", "service": "ssh", "source_ip": "192.168.1.2", "username": "user1"},
        {"event_type": "authentication_failure", "service": "ssh", "source_ip": "192.168.1.1", "username": "admin"},
        {"event_type": "authentication_failure", "service": "ssh", "source_ip": "192.168.1.1", "username": "admin"},
    ]
    
    for event in events:
        alerts = engine.process_event(event)
        for alert in alerts:
            print(f"Alert: {alert.title}")
            print(f"  Severity: {alert.severity.name}")
            print(f"  Details: {json.dumps(alert.details, indent=2)}\n")
