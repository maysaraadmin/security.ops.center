"""
Network Intrusion Prevention System (NIPS) rule engine.

This module provides the rule processing logic for the NIPS service.
"""
import re
import ipaddress
from typing import Dict, List, Optional, Set, Any, Tuple, Union, Callable
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from collections import defaultdict, deque
import socket
import struct

from src.common.logging_utils import setup_logger
from src.common.utils import RateLimiter, Timer
from src.common.constants import Protocol, Action, Severity

from src.services.nips.models import NIPSRule, NIPSAlert, NIPSRuleType, NIPSStats

# Type aliases
RuleMatcher = Callable[[Dict[str, Any], NIPSRule], bool]
PacketInfo = Dict[str, Any]

class NIPSRuleEngine:
    """Engine for processing network packets against NIPS rules."""
    
    def __init__(self, logger=None):
        """Initialize the NIPS rule engine."""
        self.logger = logger or setup_logger(__name__)
        self.rules: Dict[str, NIPSRule] = {}
        self.rule_matchers: Dict[NIPSRuleType, RuleMatcher] = {
            NIPSRuleType.SIGNATURE: self._match_signature_rule,
            NIPSRuleType.ANOMALY: self._match_anomaly_rule,
            NIPSRuleType.PROTOCOL: self._match_protocol_rule,
            NIPSRuleType.RATE: self._match_rate_rule,
            NIPSRuleType.GEO: self._match_geo_rule,
            NIPSRuleType.REPUTATION: self._match_reputation_rule,
        }
        
        # Rate limiting and state tracking
        self.rate_limiters: Dict[str, RateLimiter] = {}
        self.alert_history: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))
        self.packet_history: Dict[str, deque] = defaultdict(lambda: deque(maxlen=10000))
        self.anomaly_scores: Dict[str, float] = defaultdict(float)
        
        # Statistics
        self.stats = NIPSStats(timestamp=datetime.utcnow())
        self.last_stats_update = datetime.utcnow()
    
    def add_rule(self, rule: NIPSRule) -> bool:
        """Add a rule to the engine."""
        if rule.id in self.rules:
            self.logger.warning(f"Rule with ID {rule.id} already exists, updating")
            
        self.rules[rule.id] = rule
        self.stats.rules_loaded = len(self.rules)
        self.stats.rules_active = sum(1 for r in self.rules.values() if r.enabled)
        
        # Initialize rate limiter if needed
        if rule.rule_type == NIPSRuleType.RATE and rule.id not in self.rate_limiters:
            # Extract rate limit parameters from metadata or use defaults
            rate = rule.metadata.get('rate', 10)  # Default: 10 packets per second
            capacity = rule.metadata.get('burst', 20)  # Default: 20 packet burst
            self.rate_limiters[rule.id] = RateLimiter(rate=rate, capacity=capacity)
        
        return True
    
    def remove_rule(self, rule_id: str) -> bool:
        """Remove a rule from the engine."""
        if rule_id in self.rules:
            del self.rules[rule_id]
            if rule_id in self.rate_limiters:
                del self.rate_limiters[rule_id]
            
            self.stats.rules_loaded = len(self.rules)
            self.stats.rules_active = sum(1 for r in self.rules.values() if r.enabled)
            return True
        return False
    
    def enable_rule(self, rule_id: str, enabled: bool = True) -> bool:
        """Enable or disable a rule."""
        if rule_id in self.rules:
            self.rules[rule_id].enabled = enabled
            self.rules[rule_id].updated_at = datetime.utcnow()
            self.stats.rules_active = sum(1 for r in self.rules.values() if r.enabled)
            return True
        return False
    
    def process_packet(self, packet_info: PacketInfo) -> List[NIPSAlert]:
        """
        Process a network packet against all enabled rules.
        
        Args:
            packet_info: Dictionary containing packet information
            
        Returns:
            List of alerts generated by matching rules
        """
        if not packet_info:
            return []
        
        alerts = []
        self.stats.packets_processed += 1
        
        # Update packet history for anomaly detection
        src_dst_key = f"{packet_info.get('src_ip')}:{packet_info.get('dst_ip')}"
        self.packet_history[src_dst_key].append((datetime.utcnow(), packet_info))
        
        # Check against each rule
        for rule in self.rules.values():
            if not rule.enabled:
                continue
                
            try:
                matcher = self.rule_matchers.get(rule.rule_type)
                if matcher and matcher(packet_info, rule):
                    # Rule matched, create alert
                    alert = self._create_alert(rule, packet_info)
                    alerts.append(alert)
                    self.alert_history[rule.id].append(alert)
                    self.stats.alerts_triggered += 1
                    
                    # Take action if specified
                    if rule.action in (Action.DROP, Action.REJECT, Action.BLOCK):
                        self.stats.packets_dropped += 1
                        break  # Stop processing further rules if packet is dropped
                    else:
                        self.stats.packets_allowed += 1
            except Exception as e:
                self.logger.error(f"Error processing rule {rule.id}: {e}", exc_info=True)
        else:
            # No rules matched with DROP/REJECT/BLOCK actions
            self.stats.packets_allowed += 1
        
        # Update statistics periodically
        self._update_statistics()
        
        return alerts
    
    def _match_signature_rule(self, packet: PacketInfo, rule: NIPSRule) -> bool:
        """Match packet against a signature-based rule."""
        # Check protocol if specified
        if rule.protocol and packet.get('protocol') != rule.protocol:
            return False
            
        # Check source/destination IPs
        if rule.source_ips and packet.get('src_ip') not in rule.source_ips:
            return False
        if rule.destination_ips and packet.get('dst_ip') not in rule.destination_ips:
            return False
            
        # Check source/destination ports
        if rule.source_ports and packet.get('src_port') not in rule.source_ports:
            return False
        if rule.destination_ports and packet.get('dst_port') not in rule.destination_ports:
            return False
            
        # Check for pattern in payload
        if rule.pattern and 'payload' in packet:
            if isinstance(packet['payload'], bytes):
                try:
                    payload = packet['payload'].decode('utf-8', errors='ignore')
                except UnicodeDecodeError:
                    payload = str(packet['payload'])
            else:
                payload = str(packet['payload'])
                
            if not re.search(rule.pattern, payload, re.IGNORECASE | re.DOTALL):
                return False
        
        return True
    
    def _match_anomaly_rule(self, packet: PacketInfo, rule: NIPSRule) -> bool:
        """Match packet against an anomaly-based rule."""
        # This is a simplified example - in a real implementation, you would use
        # machine learning models or statistical analysis to detect anomalies
        
        # Get recent packets for this flow
        src_dst_key = f"{packet.get('src_ip')}:{packet.get('dst_ip')}"
        recent_packets = list(self.packet_history[src_dst_key])
        
        # Simple example: Check for unusual packet size
        if 'length' in packet:
            packet_size = packet['length']
            if recent_packets:
                avg_size = sum(p[1].get('length', 0) for p in recent_packets) / len(recent_packets)
                if packet_size > avg_size * 3:  # Packet is 3x larger than average
                    return True
        
        return False
    
    def _match_protocol_rule(self, packet: PacketInfo, rule: NIPSRule) -> bool:
        """Match packet against a protocol validation rule."""
        if 'protocol' not in packet:
            return False
            
        # Check if the protocol matches
        if rule.protocol and packet['protocol'] != rule.protocol:
            return False
            
        # Add protocol-specific validation here
        if packet['protocol'] == Protocol.TCP:
            # Example: Check for TCP flags anomalies
            if 'tcp_flags' in packet and packet['tcp_flags'] == 0:
                return True  # Null scan
                
        elif packet['protocol'] == Protocol.UDP:
            # Example: Check for DNS amplification attacks
            if (packet.get('dst_port') == 53 and 
                packet.get('src_port') > 1024 and 
                packet.get('length', 0) > 512):
                return True
                
        return False
    
    def _match_rate_rule(self, packet: PacketInfo, rule: NIPSRule) -> bool:
        """Match packet against a rate-based rule."""
        # Initialize rate limiter if it doesn't exist
        if rule.id not in self.rate_limiters:
            rate = rule.metadata.get('rate', 10)  # Default: 10 packets per second
            capacity = rule.metadata.get('burst', 20)  # Default: 20 packet burst
            self.rate_limiters[rule.id] = RateLimiter(rate=rate, capacity=capacity)
        
        # Create a key for rate limiting (could be source IP, destination port, etc.)
        rate_key = self._get_rate_key(packet, rule)
        
        # Check if rate limit is exceeded
        return not self.rate_limiters[rule.id].acquire(key=rate_key)
    
    def _match_geo_rule(self, packet: PacketInfo, rule: NIPSRule) -> bool:
        """Match packet against a geographic-based rule."""
        # In a real implementation, you would use a GeoIP database to look up
        # the geographic location of the source/destination IP and compare it
        # against the allowed/blocked countries in the rule metadata
        
        # This is a placeholder implementation
        if 'src_ip' in packet:
            # Example: Block traffic from specific countries
            blocked_countries = rule.metadata.get('blocked_countries', [])
            if blocked_countries:
                # In a real implementation, look up the country for src_ip
                # country = geoip_lookup(packet['src_ip'])
                # return country in blocked_countries
                pass
                
        return False
    
    def _match_reputation_rule(self, packet: PacketInfo, rule: NIPSRule) -> bool:
        """Match packet against a reputation-based rule."""
        # In a real implementation, you would check the reputation of the
        # source/destination IP against a threat intelligence feed or reputation service
        
        # This is a placeholder implementation
        if 'src_ip' in packet:
            # Example: Block known malicious IPs
            malicious_ips = rule.metadata.get('malicious_ips', [])
            if packet['src_ip'] in malicious_ips:
                return True
                
        return False
    
    def _get_rate_key(self, packet: PacketInfo, rule: NIPSRule) -> str:
        """Generate a rate limiting key based on the rule configuration."""
        key_parts = []
        
        # Include source IP if specified or by default
        if rule.metadata.get('rate_by_src_ip', True) and 'src_ip' in packet:
            key_parts.append(f"src:{packet['src_ip']}")
            
        # Include destination IP if specified
        if rule.metadata.get('rate_by_dst_ip', False) and 'dst_ip' in packet:
            key_parts.append(f"dst:{packet['dst_ip']}")
            
        # Include protocol if specified
        if rule.metadata.get('rate_by_protocol', False) and 'protocol' in packet:
            key_parts.append(f"proto:{packet['protocol'].name}")
            
        # Include destination port if specified
        if rule.metadata.get('rate_by_dst_port', False) and 'dst_port' in packet:
            key_parts.append(f"dport:{packet['dst_port']}")
            
        # If no specific rate limiting fields are specified, use source IP by default
        if not key_parts and 'src_ip' in packet:
            key_parts.append(f"src:{packet['src_ip']}")
            
        return "|".join(key_parts) if key_parts else "default"
    
    def _create_alert(self, rule: NIPSRule, packet: PacketInfo) -> NIPSAlert:
        """Create an alert for a rule match."""
        alert_id = f"nips_{int(datetime.utcnow().timestamp())}_{len(self.alert_history)}"
        
        # Create a summary of the packet
        packet_summary = (
            f"{packet.get('protocol', 'UNKNOWN')} "
            f"{packet.get('src_ip', '0.0.0.0')}:{packet.get('src_port', 0)} -> "
            f"{packet.get('dst_ip', '0.0.0.0')}:{packet.get('dst_port', 0)}"
        )
        
        # Include additional context in metadata
        metadata = {
            'rule_type': rule.rule_type.value,
            'packet_length': packet.get('length', 0),
            'timestamp': datetime.utcnow().isoformat(),
            **rule.metadata
        }
        
        return NIPSAlert(
            id=alert_id,
            rule_id=rule.id,
            rule_name=rule.name,
            timestamp=datetime.utcnow(),
            source_ip=packet.get('src_ip', '0.0.0.0'),
            destination_ip=packet.get('dst_ip', '0.0.0.0'),
            source_port=packet.get('src_port', 0),
            destination_port=packet.get('dst_port', 0),
            protocol=packet.get('protocol', Protocol.OTHER),
            severity=rule.severity,
            action_taken=rule.action,
            packet_summary=packet_summary,
            raw_packet=packet.get('raw'),
            metadata=metadata
        )
    
    def _update_statistics(self) -> None:
        """Update statistics periodically."""
        now = datetime.utcnow()
        if (now - self.last_stats_update).total_seconds() < 60:  # Update every minute
            return
            
        # Calculate network throughput
        total_bytes = sum(
            sum(p[1].get('length', 0) for p in packets)
            for packets in self.packet_history.values()
        )
        elapsed = (now - self.last_stats_update).total_seconds()
        
        # Update stats
        self.stats.timestamp = now
        self.stats.network_throughput = (total_bytes / (1024 * 1024)) / max(elapsed, 1)  # MB/s
        self.last_stats_update = now
    
    def get_statistics(self) -> NIPSStats:
        """Get the current statistics."""
        # Ensure stats are up to date
        self._update_statistics()
        return self.stats
    
    def reset_statistics(self) -> None:
        """Reset all statistics counters."""
        self.stats = NIPSStats(timestamp=datetime.utcnow())
        self.last_stats_update = datetime.utcnow()
        
        # Reset rate limiters
        for limiter in self.rate_limiters.values():
            limiter.reset()
    
    def get_recent_alerts(self, limit: int = 100) -> List[NIPSAlert]:
        """Get the most recent alerts."""
        all_alerts = []
        for alerts in self.alert_history.values():
            all_alerts.extend(alerts)
        
        # Sort by timestamp descending
        all_alerts.sort(key=lambda x: x.timestamp, reverse=True)
        return all_alerts[:limit]
    
    def get_alerts_by_rule(self, rule_id: str, limit: int = 100) -> List[NIPSAlert]:
        """Get recent alerts for a specific rule."""
        return list(self.alert_history.get(rule_id, [])[-limit:])
    
    def clear_alerts(self, rule_id: str = None) -> None:
        """Clear alerts, optionally for a specific rule."""
        if rule_id:
            if rule_id in self.alert_history:
                self.alert_history[rule_id].clear()
        else:
            self.alert_history.clear()
    
    def __del__(self):
        """Clean up resources."""
        self.clear_alerts()
        self.rate_limiters.clear()
        self.packet_history.clear()
        self.anomaly_scores.clear()
