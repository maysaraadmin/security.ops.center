"""
Network Intrusion Prevention System (NIPS) data models.

This module defines the data models used by the NIPS service.
"""
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Any, Union
from datetime import datetime

from src.common.constants import Protocol, Action, Severity

class NIPSRuleType(Enum):
    """Types of NIPS rules."""
    SIGNATURE = "signature"  # Pattern-based detection
    ANOMALY = "anomaly"     # Behavioral anomaly detection
    PROTOCOL = "protocol"   # Protocol validation
    RATE = "rate"           # Rate-based detection
    GEO = "geo"             # Geographic-based rules
    REPUTATION = "reputation"  # IP/host reputation

@dataclass
class NIPSRule:
    """Represents a NIPS rule for detecting and preventing network intrusions."""
    id: str
    name: str
    description: str
    rule_type: NIPSRuleType
    pattern: Optional[str] = None
    protocol: Optional[Protocol] = None
    source_ips: List[str] = field(default_factory=list)
    destination_ips: List[str] = field(default_factory=list)
    source_ports: List[int] = field(default_factory=list)
    destination_ports: List[int] = field(default_factory=list)
    action: Action = Action.ALERT
    severity: Severity = Severity.MEDIUM
    enabled: bool = True
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the rule to a dictionary."""
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'rule_type': self.rule_type.value,
            'pattern': self.pattern,
            'protocol': self.protocol.value if self.protocol else None,
            'source_ips': self.source_ips,
            'destination_ips': self.destination_ips,
            'source_ports': self.source_ports,
            'destination_ports': self.destination_ports,
            'action': self.action.value,
            'severity': self.severity.name,
            'enabled': self.enabled,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat(),
            'metadata': self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'NIPSRule':
        """Create a NIPSRule from a dictionary."""
        return cls(
            id=data.get('id', ''),
            name=data.get('name', ''),
            description=data.get('description', ''),
            rule_type=NIPSRuleType(data.get('rule_type', NIPSRuleType.SIGNATURE.value)),
            pattern=data.get('pattern'),
            protocol=Protocol(data['protocol']) if data.get('protocol') else None,
            source_ips=data.get('source_ips', []),
            destination_ips=data.get('destination_ips', []),
            source_ports=data.get('source_ports', []),
            destination_ports=data.get('destination_ports', []),
            action=Action(data.get('action', Action.ALERT.value)),
            severity=Severity[data.get('severity', 'MEDIUM')],
            enabled=data.get('enabled', True),
            created_at=datetime.fromisoformat(data['created_at']) if 'created_at' in data else datetime.utcnow(),
            updated_at=datetime.fromisoformat(data['updated_at']) if 'updated_at' in data else datetime.utcnow(),
            metadata=data.get('metadata', {})
        )

@dataclass
class NIPSAlert:
    """Represents an alert generated by the NIPS."""
    id: str
    rule_id: str
    rule_name: str
    timestamp: datetime
    source_ip: str
    destination_ip: str
    source_port: int
    destination_port: int
    protocol: Protocol
    severity: Severity
    action_taken: Action
    packet_summary: str
    raw_packet: Optional[bytes] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the alert to a dictionary."""
        return {
            'id': self.id,
            'rule_id': self.rule_id,
            'rule_name': self.rule_name,
            'timestamp': self.timestamp.isoformat(),
            'source_ip': self.source_ip,
            'destination_ip': self.destination_ip,
            'source_port': self.source_port,
            'destination_port': self.destination_port,
            'protocol': self.protocol.value,
            'severity': self.severity.name,
            'action_taken': self.action_taken.value,
            'packet_summary': self.packet_summary,
            'raw_packet': self.raw_packet.hex() if self.raw_packet else None,
            'metadata': self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'NIPSAlert':
        """Create a NIPSAlert from a dictionary."""
        return cls(
            id=data['id'],
            rule_id=data['rule_id'],
            rule_name=data['rule_name'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            source_ip=data['source_ip'],
            destination_ip=data['destination_ip'],
            source_port=data['source_port'],
            destination_port=data['destination_port'],
            protocol=Protocol(data['protocol']),
            severity=Severity[data['severity']],
            action_taken=Action(data['action_taken']),
            packet_summary=data['packet_summary'],
            raw_packet=bytes.fromhex(data['raw_packet']) if data.get('raw_packet') else None,
            metadata=data.get('metadata', {})
        )

@dataclass
class NIPSStats:
    """NIPS performance and detection statistics."""
    timestamp: datetime
    packets_processed: int = 0
    packets_dropped: int = 0
    packets_allowed: int = 0
    alerts_triggered: int = 0
    rules_loaded: int = 0
    rules_active: int = 0
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    network_throughput: float = 0.0  # in MB/s
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the stats to a dictionary."""
        return {
            'timestamp': self.timestamp.isoformat(),
            'packets_processed': self.packets_processed,
            'packets_dropped': self.packets_dropped,
            'packets_allowed': self.packets_allowed,
            'alerts_triggered': self.alerts_triggered,
            'rules_loaded': self.rules_loaded,
            'rules_active': self.rules_active,
            'cpu_usage': self.cpu_usage,
            'memory_usage': self.memory_usage,
            'network_throughput': self.network_throughput
        }
