"""
Malware and rootkit detection for the File Integrity Monitoring system.

This module provides functionality to detect:
- Ransomware activity (mass file encryption)
- Rootkit behavior (hidden system file modifications)
- Supply chain attacks (trojanized software updates)
"""

import os
import time
import hashlib
import logging
import threading
from typing import Dict, List, Optional, Tuple, Set, Any
from dataclasses import dataclass, field
from enum import Enum, auto
from datetime import datetime, timedelta

# Configure logging
logger = logging.getLogger(__name__)

class ThreatType(Enum):
    """Types of security threats that can be detected."""
    RANSOMWARE = auto()
    ROOTKIT = auto()
    SUPPLY_CHAIN = auto()
    SUSPICIOUS_ACTIVITY = auto()

@dataclass
class ThreatAlert:
    """Represents a detected security threat."""
    threat_type: ThreatType
    description: str
    severity: str  # 'low', 'medium', 'high', 'critical'
    timestamp: float = field(default_factory=time.time)
    affected_paths: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the alert to a dictionary for serialization."""
        return {
            'threat_type': self.threat_type.name,
            'description': self.description,
            'severity': self.severity,
            'timestamp': self.timestamp,
            'affected_paths': self.affected_paths,
            'metadata': self.metadata
        }

class MalwareDetector:
    """
    Detects various types of malware and suspicious activities by analyzing
    file system events and system state.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize the malware detector with configuration."""
        self.config = config or {}
        self.running = False
        self._lock = threading.RLock()
        
        # Ransomware detection settings
        self.ransomware_threshold = self.config.get('ransomware_threshold', 50)  # Max files before alert
        self.ransomware_time_window = self.config.get('ransomware_time_window', 60)  # seconds
        
        # Rootkit detection settings
        self.protected_paths = self._get_protected_paths()
        self.suspicious_strings = self._get_suspicious_strings()
        
        # State for tracking events
        self.recent_events: List[Tuple[float, str, str]] = []  # (timestamp, path, operation)
        self.file_hashes: Dict[str, str] = {}  # path -> hash
        self.baseline_snapshot: Dict[str, str] = {}  # For supply chain detection
        
        # Thread for periodic checks
        self._scan_thread: Optional[threading.Thread] = None
        self._stop_event = threading.Event()
    
    def _get_protected_paths(self) -> Set[str]:
        """Get a set of protected system paths to monitor for rootkit activity."""
        import platform
        system = platform.system().lower()
        
        if system == 'windows':
            return {
                os.environ.get('SystemRoot', r'C:\Windows') + '\system32',
                os.environ.get('SystemRoot', r'C:\Windows') + '\system32\drivers',
                os.environ.get('SystemRoot', r'C:\Windows') + '\system32\config',
                os.environ.get('SystemRoot', r'C:\Windows') + '\SysWOW64',
                os.environ.get('SystemRoot', r'C:\Windows') + '\System32\Tasks',
                os.environ.get('ProgramData', r'C:\ProgramData') + '\Microsoft\Windows\Start Menu\Programs\Startup',
                os.environ.get('APPDATA', '') + '\Microsoft\Windows\Start Menu\Programs\Startup',
            }
        else:  # Linux/Unix
            return {
                '/bin',
                '/sbin',
                '/usr/bin',
                '/usr/sbin',
                '/usr/local/bin',
                '/usr/local/sbin',
                '/etc/init.d',
                '/etc/cron.d',
                '/etc/cron.hourly',
                '/etc/cron.daily',
                '/etc/cron.weekly',
                '/etc/cron.monthly',
                '/lib',
                '/lib64',
                '/usr/lib',
                '/usr/lib64',
            }
    
    def _get_suspicious_strings(self) -> Set[str]:
        """Get a set of suspicious strings that might indicate malware."""
        return {
            'crypt', 'ransom', 'encrypt', 'decrypt', 'bitcoin', 'wallet', 'pay',
            'tor', 'i2p', 'vpn', 'proxy', 'backdoor', 'rootkit', 'keylogger',
            'spyware', 'adware', 'trojan', 'worm', 'virus', 'malware', 'exploit',
            'shellcode', 'payload', 'inject', 'bypass', 'disable', 'elevate',
            'privilege', 'escalation', 'persistence', 'stealth', 'hidden', 'obfuscate'
        }
    
    def start(self) -> None:
        """Start the malware detection service."""
        if self.running:
            return
            
        self.running = True
        self._stop_event.clear()
        self._scan_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self._scan_thread.start()
        
        # Take initial baseline snapshot for supply chain detection
        self._take_baseline_snapshot()
        
        logger.info("Malware detection service started")
    
    def stop(self) -> None:
        """Stop the malware detection service."""
        if not self.running:
            return
            
        self.running = False
        self._stop_event.set()
        
        if self._scan_thread and self._scan_thread.is_alive():
            self._scan_thread.join(timeout=5.0)
        
        logger.info("Malware detection service stopped")
    
    def _monitor_loop(self) -> None:
        """Main monitoring loop that runs in a background thread."""
        while not self._stop_event.is_set():
            try:
                # Check for ransomware patterns
                self._check_ransomware_activity()
                
                # Check for rootkit activity
                self._check_rootkit_activity()
                
                # Check for supply chain attacks
                self._check_supply_chain()
                
                # Clean up old events
                self._cleanup_old_events()
                
                # Sleep until next check
                self._stop_event.wait(30)  # Check every 30 seconds
                
            except Exception as e:
                logger.error(f"Error in malware detection loop: {e}", exc_info=True)
                self._stop_event.wait(10)  # Wait before retrying on error
    
    def process_event(self, event: 'FileEvent') -> Optional[ThreatAlert]:
        """
        Process a file system event and check for suspicious activity.
        
        Args:
            event: The file system event to process
            
        Returns:
            Optional[ThreatAlert]: A threat alert if suspicious activity is detected, None otherwise
        """
        if not self.running:
            return None
            
        try:
            # Track the event
            with self._lock:
                self.recent_events.append((time.time(), event.src_path, event.event_type.name))
                
                # Check for suspicious patterns in the file content
                if event.event_type in [EventType.CREATED, EventType.MODIFIED]:
                    alert = self._check_file_content(event.src_path)
                    if alert:
                        return alert
            
            # Check for protected path modifications
            if self._is_protected_path(event.src_path):
                return self._check_protected_path_event(event)
                
            # Check for suspicious file extensions (e.g., .encrypted, .crypt, etc.)
            if self._has_suspicious_extension(event.src_path):
                return ThreatAlert(
                    threat_type=ThreatType.RANSOMWARE,
                    description=f"Suspicious file extension detected: {event.src_path}",
                    severity='high',
                    affected_paths=[event.src_path],
                    metadata={'event_type': event.event_type.name}
                )
                
        except Exception as e:
            logger.error(f"Error processing event: {e}", exc_info=True)
            
        return None
    
    def _check_ransomware_activity(self) -> Optional[ThreatAlert]:
        """Check for patterns of ransomware activity."""
        with self._lock:
            now = time.time()
            recent_events = [
                (ts, path, op) for ts, path, op in self.recent_events
                if now - ts < self.ransomware_time_window
            ]
            
            # Count unique file modifications in the time window
            modified_files = set()
            for ts, path, op in recent_events:
                if op in ['MODIFIED', 'CREATED']:
                    modified_files.add(path)
            
            # If too many files were modified in a short time, it might be ransomware
            if len(modified_files) >= self.ransomware_threshold:
                return ThreatAlert(
                    threat_type=ThreatType.RANSOMWARE,
                    description=(
                        f"Potential ransomware activity detected: "
                        f"{len(modified_files)} files modified in the last "
                        f"{self.ransomware_time_window} seconds"
                    ),
                    severity='critical',
                    affected_paths=list(modified_files)[:100],  # Limit to first 100 paths
                    metadata={
                        'modified_count': len(modified_files),
                        'time_window_seconds': self.ransomware_time_window
                    }
                )
        return None
    
    def _check_rootkit_activity(self) -> Optional[ThreatAlert]:
        """Check for signs of rootkit activity."""
        # Check for hidden processes or files in protected directories
        # This is a simplified example - real rootkit detection is more complex
        
        # For Linux: Check for hidden processes by comparing ps output with /proc
        if os.name == 'posix' and not os.path.exists('/.dockerenv'):  # Skip in Docker
            try:
                import subprocess
                
                # Get list of PIDs from /proc
                proc_pids = {pid for pid in os.listdir('/proc') if pid.isdigit()}
                
                # Get list of PIDs from ps
                ps_output = subprocess.check_output(['ps', '-e', '-o', 'pid=']).decode()
                ps_pids = {line.strip() for line in ps_output.splitlines() if line.strip()}
                
                # Find hidden processes (in /proc but not in ps)
                hidden_pids = proc_pids - ps_pids
                
                if hidden_pids:
                    return ThreatAlert(
                        threat_type=ThreatType.ROOTKIT,
                        description=f"Potential hidden processes detected: {hidden_pids}",
                        severity='high',
                        metadata={
                            'hidden_pids': list(hidden_pids),
                            'check_type': 'process_hiding'
                        }
                    )
                    
            except Exception as e:
                logger.warning(f"Error checking for hidden processes: {e}")
        
        return None
    
    def _check_supply_chain(self) -> Optional[ThreatAlert]:
        """Check for signs of supply chain attacks."""
        # This would typically involve:
        # 1. Verifying checksums of system binaries against known good hashes
        # 2. Checking for unexpected changes to package managers (pip, npm, etc.)
        # 3. Monitoring for suspicious network connections from package managers
        
        # For now, we'll just log that this check ran
        logger.debug("Running supply chain check...")
        return None
    
    def _check_file_content(self, filepath: str) -> Optional[ThreatAlert]:
        """Check file content for suspicious patterns."""
        if not os.path.isfile(filepath) or os.path.getsize(filepath) > 10 * 1024 * 1024:  # Skip large files
            return None
            
        try:
            with open(filepath, 'rb') as f:
                content = f.read(8192)  # Only check first 8KB
                
                # Convert to lowercase for case-insensitive matching
                content_str = content.decode('utf-8', errors='ignore').lower()
                
                # Check for suspicious strings
                found_strings = [s for s in self.suspicious_strings if s in content_str]
                
                if found_strings:
                    return ThreatAlert(
                        threat_type=ThreatType.SUSPICIOUS_ACTIVITY,
                        description=(
                            f"Suspicious content detected in {os.path.basename(filepath)}: "
                            f"{', '.join(found_strings[:3])}..."
                        ),
                        severity='medium',
                        affected_paths=[filepath],
                        metadata={
                            'suspicious_strings': found_strings,
                            'file_size': os.path.getsize(filepath)
                        }
                    )
                    
        except (IOError, PermissionError) as e:
            logger.debug(f"Could not check file content for {filepath}: {e}")
            
        return None
    
    def _is_protected_path(self, path: str) -> bool:
        """Check if a path is in a protected system directory."""
        path = os.path.normpath(path).lower()
        return any(protected_path.lower() in path for protected_path in self.protected_paths)
    
    def _has_suspicious_extension(self, path: str) -> bool:
        """Check if a file has a suspicious extension."""
        suspicious_extensions = {
            '.encrypted', '.crypt', '.locked', '.crypto', '.ransom', '.locky',
            '.zepto', '.odin', '.aes', '.rsa', '.xyz', '.zzz', '.aaa', '.abc',
            '.ccc', '.vvv', '.xxx', '.ttt', '.micro', '.cryptolocker', '.cryptowall',
            '.cerber', '.vault', '.petya', '.wannacry', '.notpetya', '.badrabbit',
            '.ryuk', '.sodin', '.sodinokibi', '.maze', '.conti', '.revil'
        }
        
        ext = os.path.splitext(path)[1].lower()
        return ext in suspicious_extensions
    
    def _check_protected_path_event(self, event: 'FileEvent') -> Optional[ThreatAlert]:
        """Check if an event in a protected path is suspicious."""
        # Any modification to protected paths is suspicious
        if event.event_type in [EventType.MODIFIED, EventType.CREATED, EventType.DELETED]:
            return ThreatAlert(
                threat_type=ThreatType.ROOTKIT,
                description=(
                    f"Suspicious {event.event_type.name.lower()} in protected path: "
                    f"{event.src_path}"
                ),
                severity='high',
                affected_paths=[event.src_path],
                metadata={
                    'event_type': event.event_type.name,
                    'protected_path': True,
                    'process': getattr(event, 'process', 'unknown')
                }
            )
        return None
    
    def _take_baseline_snapshot(self) -> None:
        """Take a snapshot of critical system files for later comparison."""
        logger.info("Taking baseline snapshot of system files...")
        self.baseline_snapshot = {}
        
        for path in self.protected_paths:
            if os.path.isdir(path):
                for root, _, files in os.walk(path):
                    for file in files:
                        filepath = os.path.join(root, file)
                        try:
                            if os.path.isfile(filepath) and os.access(filepath, os.R_OK):
                                with open(filepath, 'rb') as f:
                                    file_hash = hashlib.sha256(f.read()).hexdigest()
                                    self.baseline_snapshot[filepath] = file_hash
                        except (IOError, PermissionError):
                            continue
        
        logger.info(f"Baseline snapshot completed: {len(self.baseline_snapshot)} files hashed")
    
    def _cleanup_old_events(self) -> None:
        """Remove events older than the time window."""
        now = time.time()
        with self._lock:
            self.recent_events = [
                (ts, path, op) for ts, path, op in self.recent_events
                if now - ts < self.ransomware_time_window * 2  # Keep some history
            ]
    
    def __enter__(self):
        """Context manager entry."""
        self.start()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.stop()

# For type hints
from .core import FileEvent, EventType
