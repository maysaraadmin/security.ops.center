"""
Event system for the EDR.
"""
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum, auto
from typing import Dict, Any, List, Optional, Union
import uuid
import json
from pathlib import Path

class EventType(Enum):
    """Types of events that can be generated by the EDR system."""
    # Process events
    PROCESS_CREATE = "process_create"
    PROCESS_TERMINATE = "process_terminate"
    PROCESS_MODULE_LOAD = "process_module_load"
    
    # File system events
    FILE_CREATE = "file_create"
    FILE_MODIFY = "file_modify"
    FILE_DELETE = "file_delete"
    FILE_RENAME = "file_rename"
    
    # Network events
    NETWORK_CONNECT = "network_connect"
    NETWORK_LISTEN = "network_listen"
    NETWORK_DISCONNECT = "network_disconnect"
    
    # Registry events (Windows)
    REGISTRY_SET = "registry_set"
    REGISTRY_DELETE = "registry_delete"
    
    # Detection events
    THREAT_DETECTED = "threat_detected"
    
    # System events
    SYSTEM_STARTUP = "system_startup"
    SYSTEM_SHUTDOWN = "system_shutdown"
    
    # User events
    USER_LOGIN = "user_login"
    USER_LOGOUT = "user_logout"
    
    # Agent events
    AGENT_START = "agent_start"
    AGENT_STOP = "agent_stop"
    AGENT_HEARTBEAT = "agent_heartbeat"

class EventSeverity(Enum):
    """Severity levels for events."""
    DEBUG = 0
    INFO = 1
    LOW = 2
    MEDIUM = 3
    HIGH = 4
    CRITICAL = 5

@dataclass
class ProcessInfo:
    """Information about a process."""
    pid: int
    name: str
    path: str = ""
    command_line: str = ""
    parent_pid: Optional[int] = None
    parent_name: Optional[str] = None
    integrity_level: Optional[str] = None
    user: Optional[str] = None
    session_id: Optional[int] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {k: v for k, v in asdict(self).items() if v is not None}

@dataclass
class FileInfo:
    """Information about a file."""
    path: str
    size: Optional[int] = None
    created: Optional[float] = None
    modified: Optional[float] = None
    accessed: Optional[float] = None
    owner: Optional[str] = None
    group: Optional[str] = None
    mode: Optional[int] = None
    md5: Optional[str] = None
    sha1: Optional[str] = None
    sha256: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {k: v for k, v in asdict(self).items() if v is not None}

@dataclass
class NetworkInfo:
    """Information about a network connection."""
    protocol: str
    local_addr: str
    local_port: int
    remote_addr: str
    remote_port: int
    state: Optional[str] = None
    pid: Optional[int] = None
    process_name: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {k: v for k, v in asdict(self).items() if v is not None}

@dataclass
class RegistryInfo:
    """Information about a registry key or value."""
    key: str
    value: Optional[str] = None
    data: Optional[str] = None
    data_type: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {k: v for k, v in asdict(self).items() if v is not None}

@dataclass
class ThreatInfo:
    """Information about a detected threat."""
    name: str
    description: str
    severity: EventSeverity
    confidence: float  # 0.0 to 1.0
    indicators: List[Dict[str, Any]] = field(default_factory=list)
    mitre_techniques: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'name': self.name,
            'description': self.description,
            'severity': self.severity.name,
            'confidence': self.confidence,
            'indicators': self.indicators,
            'mitre_techniques': self.mitre_techniques
        }

@dataclass
class EDREvent:
    """Base class for all EDR events."""
    event_type: EventType
    timestamp: float = field(default_factory=lambda: datetime.utcnow().timestamp())
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    agent_id: str = ""
    hostname: str = ""
    process: Optional[ProcessInfo] = None
    file: Optional[FileInfo] = None
    network: Optional[NetworkInfo] = None
    registry: Optional[RegistryInfo] = None
    threat: Optional[ThreatInfo] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the event to a dictionary for serialization."""
        result = {
            'event_id': self.event_id,
            'event_type': self.event_type.value,
            'timestamp': self.timestamp,
            'agent_id': self.agent_id,
            'hostname': self.hostname,
            'metadata': self.metadata
        }
        
        # Add entity data if present
        if self.process:
            result['process'] = self.process.to_dict()
        if self.file:
            result['file'] = self.file.to_dict()
        if self.network:
            result['network'] = self.network.to_dict()
        if self.registry:
            result['registry'] = self.registry.to_dict()
        if self.threat:
            result['threat'] = self.threat.to_dict()
            
        return result
    
    def to_json(self, pretty: bool = False) -> str:
        """Convert the event to JSON."""
        if pretty:
            return json.dumps(self.to_dict(), indent=2, default=str)
        return json.dumps(self.to_dict(), default=str)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'EDREvent':
        """Create an event from a dictionary."""
        event = cls(
            event_type=EventType(data['event_type']),
            timestamp=data['timestamp'],
            event_id=data.get('event_id', str(uuid.uuid4())),
            agent_id=data.get('agent_id', ''),
            hostname=data.get('hostname', ''),
            metadata=data.get('metadata', {})
        )
        
        # Add entity data if present
        if 'process' in data:
            event.process = ProcessInfo(**data['process'])
        if 'file' in data:
            event.file = FileInfo(**data['file'])
        if 'network' in data:
            event.network = NetworkInfo(**data['network'])
        if 'registry' in data:
            event.registry = RegistryInfo(**data['registry'])
        if 'threat' in data:
            threat_data = data['threat'].copy()
            threat_data['severity'] = EventSeverity[threat_data['severity']]
            event.threat = ThreatInfo(**threat_data)
            
        return event
    
    @classmethod
    def from_json(cls, json_str: str) -> 'EDREvent':
        """Create an event from a JSON string."""
        return cls.from_dict(json.loads(json_str))
    
    def save_to_file(self, file_path: Union[str, Path]):
        """Save the event to a file."""
        file_path = Path(file_path)
        file_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(file_path, 'w') as f:
            json.dump(self.to_dict(), f, indent=2)
    
    @classmethod
    def load_from_file(cls, file_path: Union[str, Path]) -> 'EDREvent':
        """Load an event from a file."""
        with open(file_path, 'r') as f:
            return cls.from_dict(json.load(f))
