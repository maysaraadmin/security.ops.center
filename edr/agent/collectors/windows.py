""\nWindows-specific collectors for the EDR agent.\n"""\nimport os\nimport re\nimport sys\nimport time\nimport ctypes\nimport winreg\nimport socket\nimport struct\nimport ctypes.wintypes\nimport win32api\nimport win32con\nimport win32evtlog\nimport win32security\nimport win32process\nimport win32service\nimport win32serviceutil\nimport win32ts\nimport wmi\nimport psutil\nimport logging\nfrom typing import Dict, List, Any, Optional, Tuple, Set\n\nfrom .base import BaseCollector\nfrom ..models import ProcessInfo, FileInfo, NetworkConnection, Event\n\nlogger = logging.getLogger('edr.agent.collector.windows')\n\n# Constants for Windows API\nPROCESS_QUERY_INFORMATION = 0x0400\nPROCESS_VM_READ = 0x0010\nTH32CS_SNAPPROCESS = 0x00000002\nINVALID_HANDLE_VALUE = -1\n\nclass WindowsCollector(BaseCollector):\n    """Windows-specific collector implementation."""\n    \n    def __init__(self, name: str, config: Dict[str, Any]):\n        """Initialize the Windows collector."""\n        super().__init__(name, config)\n        self.wmi = wmi.WMI()\n        self._privileges_enabled = False\n        self._setup_privileges()\n        self._process_cache = {}\n        self._last_process_scan = 0\n        self._process_scan_interval = 60  # seconds\n    \n    def _setup_privileges(self) -> None:\n        """Enable required privileges for process and system access."""\n        try:\n            # Enable debug privilege\n            h_token = ctypes.wintypes.HANDLE()\n            if ctypes.windll.advapi32.OpenProcessToken(\n                ctypes.windll.kernel32.GetCurrentProcess(),\n                win32security.TOKEN_ADJUST_PRIVILEGES | win32security.TOKEN_QUERY,\n                ctypes.byref(h_token)\n            ):\n                luid = win32security.LookupPrivilegeValue(None, win32security.SE_DEBUG_NAME)\n                win32security.AdjustTokenPrivileges(\n                    h_token,\n                    False,\n                    [(luid, win32security.SE_PRIVILEGE_ENABLED)]\n                )\n                self._privileges_enabled = True\n        except Exception as e:\n            logger.warning(f"Failed to enable debug privileges: {e}")\n    \n    def _collect(self) -> Dict[str, Any]:\n        """Collect system information specific to Windows."""\n        data = {}\n        \n        try:\n            # Collect process information\n            if 'process' in self.config.get('collectors', []):\n                data['processes'] = self._collect_processes()\n            \n            # Collect network connections\n            if 'network' in self.config.get('collectors', []):\n                data['network_connections'] = self._collect_network_connections()\n            \n            # Collect system events\n            if 'system_events' in self.config.get('collectors', []):\n                data['events'] = self._collect_system_events()\n            \n            # Collect installed software\n            if 'software' in self.config.get('collectors', []):\n                data['installed_software'] = self._collect_installed_software()\n            \n            # Collect system information\n            if 'system_info' in self.config.get('collectors', []):\n                data['system_info'] = self._collect_system_info()\n            \n            # Collect logged on users\n            if 'users' in self.config.get('collectors', []):\n                data['logged_in_users'] = self._collect_logged_in_users()\n            \n            # Collect services\n            if 'services' in self.config.get('collectors', []):\n                data['services'] = self._collect_services()\n            \n            # Collect scheduled tasks\n            if 'scheduled_tasks' in self.config.get('collectors', []):\n                data['scheduled_tasks'] = self._collect_scheduled_tasks()\n            \n            # Collect registry information\n            if 'registry' in self.config.get('collectors', []):\n                data['registry'] = self._collect_registry_info()\n            \n        except Exception as e:\n            logger.error(f"Error in Windows collector: {e}", exc_info=True)\n        \n        return data\n    \n    def _collect_processes(self) -> List[Dict[str, Any]]:\n        """Collect information about running processes."""\n        processes = []\n        current_time = time.time()\n        \n        # Only refresh the full process list periodically\n        if current_time - self._last_process_scan > self._process_scan_interval:\n            self._process_cache = {}\n            self._last_process_scan = current_time\n        \n        try:\n            for proc in psutil.process_iter(['pid', 'name', 'username', 'cmdline', 'status',\n                                           'create_time', 'cpu_percent', 'memory_percent', 'num_threads',\n                                           'connections', 'open_files', 'environ']):\n                try:\n                    proc_info = proc.info\n                    pid = proc_info['pid']\n                    \n                    # Skip if we've already processed this process recently\n                    if pid in self._process_cache:\n                        processes.append(self._process_cache[pid])\n                        continue\n                    \n                    # Get process details\n                    process_data = {\n                        'pid': pid,\n                        'name': proc_info['name'],\n                        'cmdline': proc_info['cmdline'] or [],\n                        'username': proc_info['username'],\n                        'status': proc_info['status'],\n                        'create_time': proc_info['create_time'],\n                        'cpu_percent': proc_info['cpu_percent'],\n                        'memory_percent': proc_info['memory_percent'],\n                        'num_threads': proc_info['num_threads'],\n                        'exe': proc.exe() if hasattr(proc, 'exe') else None,\n                        'cwd': proc.cwd() if hasattr(proc, 'cwd') else None,\n                        'ppid': proc.ppid() if hasattr(proc, 'ppid') else None,\n                        'parent_name': proc.parent().name() if proc.parent() else None,\n                        'children': [{\n                            'pid': child.pid,\n                            'name': child.name()\n                        } for child in proc.children()],\n                        'connections': [{\n                            'fd': conn.fd,\n                            'family': conn.family,\n                            'type': conn.type,\n                            'laddr': conn.laddr,\n                            'raddr': conn.raddr,\n                            'status': conn.status\n                        } for conn in proc_info.get('connections', [])],\n                        'open_files': [f.path for f in proc_info.get('open_files', [])],\n                        'environment': proc_info.get('environ', {})\n                    }\n                    \n                    # Cache the process data\n                    self._process_cache[pid] = process_data\n                    processes.append(process_data)\n                    \n                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:\n                    logger.debug(f"Skipping process: {e}")\n                    continue\n                except Exception as e:\n                    logger.warning(f"Error processing process: {e}", exc_info=True)\n                    continue\n                    \n        except Exception as e:\n            logger.error(f"Error collecting processes: {e}", exc_info=True)\n        \n        return processes\n    \n    def _collect_network_connections(self) -> List[Dict[str, Any]]:\n        """Collect network connection information."""\n        connections = []\n        \n        try:\n            for conn in psutil.net_connections(kind='inet'):\n                try:\n                    conn_data = {\n                        'fd': conn.fd,\n                        'family': conn.family.name,\n                        'type': conn.type.name,\n                        'laddr': f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else None,\n                        'raddr': f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else None,\n                        'status': conn.status,\n                        'pid': conn.pid\n                    }\n                    \n                    # Add process name if available\n                    if conn.pid:\n                        try:\n                            p = psutil.Process(conn.pid)\n                            conn_data['process_name'] = p.name()\n                        except (psutil.NoSuchProcess, psutil.AccessDenied):\n                            pass\n                    \n                    connections.append(conn_data)\n                except Exception as e:\n                    logger.debug(f"Skipping connection: {e}")\n                    continue\n                    \n        except Exception as e:\n            logger.error(f"Error collecting network connections: {e}", exc_info=True)\n        \n        return connections\n    \n    def _collect_system_events(self) -> List[Dict[str, Any]]:\n        """Collect system events from the Windows Event Log."""\n        events = []\n        log_types = ['Security', 'System', 'Application']\n        \n        for log_type in log_types:\n            try:\n                hand = win32evtlog.OpenEventLog(None, log_type)\n                flags = win32evtlog.EVENTLOG_BACKWARDS_READ | win32evtlog.EVENTLOG_SEQUENTIAL_READ\n                total = win32evtlog.GetNumberOfEventLogRecords(hand)\n                \n                # Only get the most recent events\n                max_events = min(100, total)\n                if max_events == 0:\n                    continue\n                    \n                events_read = win32evtlog.ReadEventLog(\n                    hand, flags, 0, max_events\n                )\n                \n                for event in events_read:\n                    try:\n                        event_data = {\n                            'log_name': log_type,\n                            'event_id': event.EventID,\n                            'level': event.EventType,\n                            'time_generated': str(event.TimeGenerated),\n                            'source_name': event.SourceName,\n                            'computer_name': event.ComputerName,\n                            'strings': event.StringInserts or []\n                        }\n                        events.append(event_data)\n                    except Exception as e:\n                        logger.debug(f"Error processing event: {e}")\n                        continue\n                        \n            except Exception as e:\n                logger.warning(f"Error reading {log_type} log: {e}")\n                continue\n            finally:\n                try:\n                    win32evtlog.CloseEventLog(hand)\n                except Exception:\n                    pass\n        \n        return events\n    \n    def _collect_installed_software(self) -> List[Dict[str, str]]:\n        """Collect information about installed software."""\n        software = []\n        \n        try:\n            # Query 64-bit software\n            for key in [\n                r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",\n                r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"\n            ]:\n                try:\n                    hkey = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key, 0, winreg.KEY_READ | winreg.KEY_WOW64_64KEY)\n                    \n                    for i in range(0, winreg.QueryInfoKey(hkey)[0]):\n                        try:\n                            skey_name = winreg.EnumKey(hkey, i)\n                            skey = winreg.OpenKey(hkey, skey_name)\n                            \n                            try:\n                                name = winreg.QueryValueEx(skey, 'DisplayName')[0]\n                                version = winreg.QueryValueEx(skey, 'DisplayVersion')[0]\n                                publisher = winreg.QueryValueEx(skey, 'Publisher')[0] if 'Publisher' in [\n                                    winreg.EnumValue(skey, j)[0] for j in range(0, winreg.QueryInfoKey(skey)[1])\n                                ] else None\n                                \n                                software.append({\n                                    'name': name,\n                                    'version': version,\n                                    'publisher': publisher,\n                                    'install_location': winreg.QueryValueEx(skey, 'InstallLocation')[0] if 'InstallLocation' in [\n                                        winreg.EnumValue(skey, j)[0] for j in range(0, winreg.QueryInfoKey(skey)[1])\n                                    ] else None,\n                                    'uninstall_string': winreg.QueryValueEx(skey, 'UninstallString')[0] if 'UninstallString' in [\n                                        winreg.EnumValue(skey, j)[0] for j in range(0, winreg.QueryInfoKey(skey)[1])\n                                    ] else None\n                                })\n                            except (WindowsError, ValueError):\n                                continue\n                            finally:\n                                winreg.CloseKey(skey)\n                                \n                        except (WindowsError, ValueError):\n                            continue\n                            \n                    winreg.CloseKey(hkey)\n                    \n                except WindowsError as e:\n                    logger.warning(f"Error reading registry key {key}: {e}")\n                    continue\n                    \n        except Exception as e:\n            logger.error(f"Error collecting installed software: {e}", exc_info=True)\n        \n        return software\n    \n    def _collect_system_info(self) -> Dict[str, Any]:\n        """Collect system information."""\n        sys_info = {}\n        \n        try:\n            # Get system information using WMI\n            for os_info in self.wmi.Win32_OperatingSystem():\n                sys_info.update({\n                    'os_name': os_info.Caption,\n                    'os_version': os_info.Version,\n                    'os_architecture': os_info.OSArchitecture,\n                    'build_number': os_info.BuildNumber,\n                    'install_date': str(os_info.InstallDate) if os_info.InstallDate else None,\n                    'last_boot': str(os_info.LastBootUpTime) if os_info.LastBootUpTime else None,\n                    'serial_number': os_info.SerialNumber,\n                    'windows_directory': os_info.WindowsDirectory,\n                    'total_visible_memory': int(os_info.TotalVisibleMemorySize) * 1024 if os_info.TotalVisibleMemorySize else 0,\n                    'free_physical_memory': int(os_info.FreePhysicalMemory) * 1024 if os_info.FreePhysicalMemory else 0,\n                    'total_virtual_memory': int(os_info.TotalVirtualMemorySize) * 1024 if os_info.TotalVirtualMemorySize else 0,\n                    'free_virtual_memory': int(os_info.FreeVirtualMemory) * 1024 if os_info.FreeVirtualMemory else 0\n                })\n            \n            # Get CPU information\n            cpus = []\n            for cpu in self.wmi.Win32_Processor():\n                cpus.append({\n                    'name': cpu.Name,\n                    'manufacturer': cpu.Manufacturer,\n                    'max_clock_speed': cpu.MaxClockSpeed,\n                    'cores': cpu.NumberOfCores,\n                    'logical_processors': cpu.NumberOfLogicalProcessors,\n                    'architecture': cpu.Architecture,\n                    'processor_id': cpu.ProcessorId\n                })\n            sys_info['cpus'] = cpus\n            \n            # Get disk information\n            disks = []\n            for disk in self.wmi.Win32_LogicalDisk(DriveType=3):  # Fixed disks\n                disks.append({\n                    'device_id': disk.DeviceID,\n                    'size': int(disk.Size) if disk.Size else 0,\n                    'free_space': int(disk.FreeSpace) if disk.FreeSpace else 0,\n                    'file_system': disk.FileSystem,\n                    'volume_name': disk.VolumeName\n                })\n            sys_info['disks'] = disks\n            \n            # Get network adapters\n            adapters = []\n            for nic in self.wmi.Win32_NetworkAdapterConfiguration(IPEnabled=True):\n                adapters.append({\n                    'description': nic.Description,\n                    'mac_address': nic.MACAddress,\n                    'ip_addresses': nic.IPAddress or [],\n                    'subnets': nic.IPSubnet or [],\n                    'gateways': nic.DefaultIPGateway or [],\n                    'dhcp_enabled': nic.DHCPEnabled,\n                    'dns_servers': nic.DNSServerSearchOrder or []\n                })\n            sys_info['network_adapters'] = adapters\n            \n        except Exception as e:\n            logger.error(f"Error collecting system info: {e}", exc_info=True)\n        \n        return sys_info\n    \n    def _collect_logged_in_users(self) -> List[Dict[str, str]]:\n        """Collect information about logged in users."""\n        users = []\n        \n        try:\n            # Get logged on users using WTS\n            for session in win32ts.WTSEnumerateSessions(win32ts.WTS_CURRENT_SERVER_HANDLE):\n                session_id = session['SessionId']\n                if session_id == 0xFFFFFFFF:  # Skip invalid session ID\n                    continue\n                    \n                username = win32ts.WTSQuerySessionInformation(\n                    win32ts.WTS_CURRENT_SERVER_HANDLE,\n                    session_id,\n                    win32ts.WTSUserName\n                )\n                \n                if not username or username.lower() in ('', 'system', 'network service', 'local service'):\n                    continue\n                    \n                domain = win32ts.WTSQuerySessionInformation(\n                    win32ts.WTS_CURRENT_SERVER_HANDLE,\n                    session_id,\n                    win32ts.WTSDomainName\n                )\n                \n                logon_time = win32ts.WTSQuerySessionInformation(\n                    win32ts.WTS_CURRENT_SERVER_HANDLE,\n                    session_id,\n                    win32ts.WTSConnectState\n                )\n                \n                users.append({\n                    'username': f"{domain}\\{username}" if domain else username,\n                    'session_id': session_id,\n                    'logon_time': str(logon_time),\n                    'client_name': win32ts.WTSQuerySessionInformation(\n                        win32ts.WTS_CURRENT_SERVER_HANDLE,\n                        session_id,\n                        win32ts.WTSClientName\n                    ),\n                    'client_address': win32ts.WTSQuerySessionInformation(\n                        win32ts.WTS_CURRENT_SERVER_HANDLE,\n                        session_id,\n                        win32ts.WTSClientAddress\n                    ),\n                    'session_state': win32ts.WTSQuerySessionInformation(\n                        win32ts.WTS_CURRENT_SERVER_HANDLE,\n                        session_id,\n                        win32ts.WTSConnectState\n                    )\n                })\n                \n        except Exception as e:\n            logger.error(f"Error collecting logged in users: {e}", exc_info=True)\n        \n        return users\n    \n    def _collect_services(self) -> List[Dict[str, Any]]:\n        """Collect information about Windows services."""\n        services = []\n        \n        try:\n            # Get services using WMI\n            for service in self.wmi.Win32_Service():\n                services.append({\n                    'name': service.Name,\n                    'display_name': service.DisplayName,\n                    'description': service.Description,\n                    'path_name': service.PathName,\n                    'service_type': service.ServiceType,\n                    'start_mode': service.StartMode,\n                    'start_name': service.StartName,\n                    'state': service.State,\n                    'status': service.Status,\n                    'process_id': service.ProcessId,\n                    'exit_code': service.ExitCode,\n                    'tag_id': service.TagId\n                })\n                \n        except Exception as e:\n            logger.error(f"Error collecting services: {e}", exc_info=True)\n        \n        return services\n    \n    def _collect_scheduled_tasks(self) -> List[Dict[str, Any]]:\n        """Collect information about scheduled tasks."""\n        tasks = []\n        \n        try:\n            # Get tasks from Task Scheduler\n            scheduler = win32com.client.Dispatch('Schedule.Service')\n            scheduler.Connect()\n            \n            def enum_tasks(folder, base_path=''):\n                folder_path = f"{base_path}\\{folder.Name}" if base_path else folder.Name\n                \n                # Get tasks in this folder\n                for task in folder.GetTasks(1):  # TASK_ENUM_HIDDEN = 1\n                    try:\n                        task_def = task.Definition\n                        actions = []\n                        \n                        # Get task actions\n                        for action in task_def.Actions:\n                            action_info = {'type': action.Type}\n                            \n                            if action.Type == 0:  # TASK_ACTION_EXEC\n                                action_info.update({\n                                    'executable': action.Path,\n                                    'arguments': action.Arguments,\n                                    'working_directory': action.WorkingDirectory\n                                })\n                            elif action.Type == 5:  # TASK_ACTION_COM_HANDLER\n                                action_info['class_id'] = action.ClassId\n                                action_info['data'] = action.Data\n                            \n                            actions.append(action_info)\n                        \n                        # Get triggers\n                        triggers = []\n                        for trigger in task_def.Triggers:\n                            trigger_info = {\n                                'type': trigger.Type,\n                                'enabled': trigger.Enabled,\n                                'start_boundary': str(trigger.StartBoundary) if hasattr(trigger, 'StartBoundary') else None,\n                                'end_boundary': str(trigger.EndBoundary) if hasattr(trigger, 'EndBoundary') else None\n                            }\n                            triggers.append(trigger_info)\n                        \n                        # Get task settings\n                        settings = {\n                            'allow_demand_start': task.Settings.AllowDemandStart,\n                            'allow_hard_terminate': task.Settings.AllowHardTerminate,\n                            'compatibility': task.Settings.Compatibility,\n                            'delete_expired_task_after': task.Settings.DeleteExpiredTaskAfter,\n                            'disallow_start_if_on_batteries': task.Settings.DisallowStartIfOnBatteries,\n                            'enabled': task.Settings.Enabled,\n                            'execution_time_limit': task.Settings.ExecutionTimeLimit,\n                            'hidden': task.Settings.Hidden,\n                            'priority': task.Settings.Priority,\n                            'restart_count': task.Settings.RestartCount,\n                            'run_only_if_idle': task.Settings.RunOnlyIfIdle,\n                            'run_only_if_network_available': task.Settings.RunOnlyIfNetworkAvailable,\n                            'start_when_available': task.Settings.StartWhenAvailable,\n                            'stop_if_going_on_batteries': task.Settings.StopIfGoingOnBatteries,\n                            'wake_to_run': task.Settings.WakeToRun\n                        }\n                        \n                        tasks.append({\n                            'name': task.Name,\n                            'path': task.Path,\n                            'state': task.State,\n                            'enabled': task.Enabled,\n                            'last_run_time': str(task.LastRunTime) if task.LastRunTime else None,\n                            'last_task_result': task.LastTaskResult,\n                            'next_run_time': str(task.NextRunTime) if task.NextRunTime else None,\n                            'number_of_missed_runs': task.NumberOfMissedRuns,\n                            'actions': actions,\n                            'triggers': triggers,\n                            'settings': settings\n                        })\n                        \n                    except Exception as e:\n                        logger.debug(f"Error processing task {task.Name}: {e}")\n                        continue\n                \n                # Process subfolders\n                for subfolder in folder.GetFolders(0):\n                    enum_tasks(subfolder, folder_path)\n            \n            # Start enumeration from the root folder\n            root_folder = scheduler.GetFolder('\\')\n            enum_tasks(root_folder)\n            \n        except Exception as e:\n            logger.error(f"Error collecting scheduled tasks: {e}", exc_info=True)\n        \n        return tasks\n    \n    def _collect_registry_info(self) -> Dict[str, Any]:\n        """Collect important registry information."""\n        registry_info = {\n            'autoruns': self._collect_autoruns(),\n            'wmi_persistence': self._check_wmi_persistence(),\n            'powershell_profiles': self._check_powershell_profiles()\n        }\n        \n        return registry_info\n    \n    def _collect_autoruns(self) -> List[Dict[str, Any]]:\n        """Collect autorun entries from common locations."""\n        autoruns = []\n        \n        # Common autorun locations\n        autorun_locations = [\n            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"),\n            (winreg.HKEY_CURRENT_USER, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"),\n            (winreg.HKEY_CURRENT_USER, r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices"),\n            (winreg.HKEY_CURRENT_USER, r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Taskman"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\VmApplet"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\CurrentControlSet\Control\Session Manager\BootExecute"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\CurrentControlSet\Control\Session Manager\SetupExecute"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\CurrentControlSet\Control\Session Manager\Execute"),\n            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options")\n        ]\n        \n        for hive, key_path in autorun_locations:\n            try:\n                with winreg.OpenKey(hive, key_path, 0, winreg.KEY_READ | winreg.KEY_WOW64_64KEY) as key:\n                    try:\n                        i = 0\n                        while True:\n                            try:\n                                name, value, value_type = winreg.EnumValue(key, i)\n                                autoruns.append({\n                                    'hive': 'HKEY_LOCAL_MACHINE' if hive == winreg.HKEY_LOCAL_MACHINE else 'HKEY_CURRENT_USER',\n                                    'key': key_path,\n                                    'name': name,\n                                    'value': value,\n                                    'type': value_type\n                                })\n                                i += 1\n                            except WindowsError:\n                                break\n                    except WindowsError:\n                        # This is a value, not a key with values\n                        value, value_type = winreg.QueryValueEx(key, None)\n                        autoruns.append({\n                            'hive': 'HKEY_LOCAL_MACHINE' if hive == winreg.HKEY_LOCAL_MACHINE else 'HKEY_CURRENT_USER',\n                            'key': key_path,\n                            'name': '(Default)',\n                            'value': value,\n                            'type': value_type\n                        })\n            except WindowsError:\n                continue\n        \n        return autoruns\n    \n    def _check_wmi_persistence(self) -> List[Dict[str, str]]:\n        """Check for WMI event subscriptions used for persistence."""\n        wmi_persistence = []\n        \n        try:\n            # Check for WMI event filters\n            wmi_ns = self.wmi.WMI(privileges=['Security']).__getattr__('_namespace')\n            \n            # Check for event filters\n            for filter_ in wmi_ns.ExecQuery('SELECT * FROM __EventFilter'):\n                try:\n                    if any(\n                        x in filter_.Query.lower()\n                        for x in ['startup', 'logon', 'userlogon', 'shellstartup']\n                    ):\n                        wmi_persistence.append({\n                            'type': 'Event Filter',\n                            'name': filter_.Name,\n                            'query': filter_.Query,\n                            'query_language': filter_.QueryLanguage\n                        })\n                except Exception:\n                    continue\n            \n            # Check for event consumers\n            for consumer in wmi_ns.ExecQuery('SELECT * FROM __EventConsumer'):\n                try:\n                    if hasattr(consumer, 'CommandLineTemplate') and consumer.CommandLineTemplate:\n                        wmi_persistence.append({\n                            'type': 'Event Consumer',\n                            'name': consumer.Name,\n                            'command_line': consumer.CommandLineTemplate,\n                            'executable_path': getattr(consumer, 'ExecutablePath', None),\n                            'working_directory': getattr(consumer, 'WorkingDirectory', None)\n                        })\n                except Exception:\n                    continue\n            \n        except Exception as e:\n            logger.error(f"Error checking WMI persistence: {e}", exc_info=True)\n        \n        return wmi_persistence\n    \n    def _check_powershell_profiles(self) -> List[Dict[str, str]]:\n        """Check for PowerShell profiles that could be used for persistence."""\n        profiles = []\n        \n        # Common PowerShell profile locations\n        ps_profile_paths = [\n            os.path.expandvars(r"%USERPROFILE%\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1"),\n            os.path.expandvars(r"%USERPROFILE%\\Documents\\WindowsPowerShell\\Microsoft.PowerShellISE_profile.ps1"),\n            os.path.expandvars(r"%USERPROFILE%\\Documents\\PowerShell\\Microsoft.PowerShell_profile.ps1"),\n            os.path.expandvars(r"%USERPROFILE%\\Documents\\PowerShell\\Microsoft.PowerShellISE_profile.ps1"),\n            os.path.expandvars(r"%WINDIR%\\System32\\WindowsPowerShell\\v1.0\\profile.ps1"),\n            os.path.expandvars(r"%WINDIR%\\System32\\WindowsPowerShell\\v1.0\\Microsoft.PowerShell_profile.ps1"),\n            os.path.expandvars(r"%WINDIR%\\SysWOW64\\WindowsPowerShell\\v1.0\\profile.ps1"),\n            os.path.expandvars(r"%WINDIR%\\SysWOW64\\WindowsPowerShell\\v1.0\\Microsoft.PowerShell_profile.ps1")\n        ]\n        \n        for profile_path in ps_profile_paths:\n            try:\n                if os.path.exists(profile_path):\n                    with open(profile_path, 'r', encoding='utf-8', errors='ignore') as f:\n                        content = f.read()\n                        \n                    # Check for suspicious patterns\n                    suspicious = []\n                    if re.search(r'(?i)invoke-?expression|iex\s*\||\$ExecutionContext', content):\n                        suspicious.append('Uses Invoke-Expression or $ExecutionContext')\n                    if re.search(r'(?i)download(string|file)|webclient|httprequest', content):\n                        suspicious.append('Makes web requests')\n                    if re.search(r'(?i)add-type\s+-memberdefinition', content):\n                        suspicious.append('Defines custom .NET types')\n                    if re.search(r'(?i)\$env:|set-item\s+env:', content):\n                        suspicious.append('Modifies environment variables')\n                    if re.search(r'(?i)start-process|start-job|invoke-command', content):\n                        suspicious.append('Starts new processes or jobs')\n                    \n                    if suspicious:\n                        profiles.append({\n                            'path': profile_path,\n                            'suspicious_patterns': suspicious,\n                            'size': os.path.getsize(profile_path),\n                            'modified': os.path.getmtime(profile_path)\n                        })\n                        \n            except Exception as e:\n                logger.debug(f"Error checking PowerShell profile {profile_path}: {e}")\n                continue\n        \n        return profiles
