""\nEDR Threat Hunting Module\nProvides proactive threat hunting capabilities using IOCs and behavioral patterns.\n"""\n\nimport os\nimport re\nimport json\nimport yaml\nimport logging\nimport hashlib\nimport ipaddress\nimport datetime\nfrom typing import Dict, List, Optional, Any, Set, Tuple, Union, Callable, Pattern\nfrom dataclasses import dataclass, field, asdict\nfrom enum import Enum, auto\nimport concurrent.futures\nimport time\nimport platform\nimport socket\nimport glob\nimport subprocess\nimport tempfile\nimport shutil\nfrom pathlib import Path\n\n# Local imports\nfrom ..monitoring.base_monitor import BaseMonitor\nfrom ..forensics.evidence import Evidence, EvidenceType\nfrom ..alerting.alert_manager import Alert, AlertSeverity\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger('edr.threat_hunting.hunter')\n\nclass IOCType(str, Enum):\n    """Types of Indicators of Compromise (IOCs)."""\n    HASH_MD5 = 'md5'\n    HASH_SHA1 = 'sha1'\n    HASH_SHA256 = 'sha256'\n    IPV4 = 'ipv4'\n    IPV6 = 'ipv6'\n    DOMAIN = 'domain'\n    URL = 'url'\n    EMAIL = 'email'\n    FILE_PATH = 'file_path'\n    REGISTRY_KEY = 'registry_key'\n    MUTEX = 'mutex'\n    CMDLINE = 'cmdline'\n    USER_AGENT = 'user_agent'\n    JA3 = 'ja3'\n    JA3S = 'ja3s'\n    SSL_CERT = 'ssl_cert'\n    CUSTOM = 'custom'\n\nclass HuntingTechnique(str, Enum):\n    """Types of threat hunting techniques."""\n    IOC_MATCH = 'ioc_match'\n    BEHAVIORAL = 'behavioral'\n    ANOMALY_DETECTION = 'anomaly_detection'\n    MACHINE_LEARNING = 'machine_learning'\n    MEMORY_ANALYSIS = 'memory_analysis'\n    LOG_ANALYSIS = 'log_analysis'\n    NETWORK_ANALYSIS = 'network_analysis'\n    PROCESS_ANALYSIS = 'process_analysis'\n    FILE_ANALYSIS = 'file_analysis'\n    REGISTRY_ANALYSIS = 'registry_analysis'\n\n@dataclass\nclass IOC:\n    """Represents an Indicator of Compromise (IOC)."""\n    value: str\n    ioc_type: IOCType\n    source: str = 'unknown'\n    first_seen: Optional[datetime.datetime] = None\n    last_seen: Optional[datetime.datetime] = None\n    tags: List[str] = field(default_factory=list)\n    description: Optional[str] = None\n    confidence: float = 0.8  # 0.0 to 1.0\n    tlp: str = 'AMBER'  # WHITE, GREEN, AMBER, RED\n    reference: Optional[str] = None\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    \n    def __post_init__(self):\n        """Validate the IOC after initialization."""\n        self._validate()\n        \n        # Set timestamps if not provided\n        now = datetime.datetime.utcnow()\n        if self.first_seen is None:\n            self.first_seen = now\n        if self.last_seen is None:\n            self.last_seen = now\n    \n    def _validate(self) -> None:\n        """Validate the IOC value based on its type."""\n        if not self.value:\n            raise ValueError("IOC value cannot be empty")\n        \n        if self.ioc_type == IOCType.IPV4:\n            try:\n                ipaddress.IPv4Address(self.value)\n            except ipaddress.AddressValueError as e:\n                raise ValueError(f"Invalid IPv4 address: {self.value}") from e\n                \n        elif self.ioc_type == IOCType.IPV6:\n            try:\n                ipaddress.IPv6Address(self.value)\n            except ipaddress.AddressValueError as e:\n                raise ValueError(f"Invalid IPv6 address: {self.value}") from e\n        \n        elif self.ioc_type in [IOCType.HASH_MD5, IOCType.HASH_SHA1, IOCType.HASH_SHA256]:\n            hash_length = {\n                IOCType.HASH_MD5: 32,\n                IOCType.HASH_SHA1: 40,\n                IOCType.HASH_SHA256: 64\n            }[self.ioc_type]\n            \n            if not re.match(f'^[a-fA-F0-9]{{{hash_length}}}$', self.value):\n                raise ValueError(f"Invalid {self.ioc_type} hash: {self.value}")\n        \n        elif self.ioc_type == IOCType.DOMAIN:\n            if not re.match(\n                r'^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$',\n                self.value\n            ):\n                raise ValueError(f"Invalid domain: {self.value}")\n        \n        elif self.ioc_type == IOCType.URL:\n            if not re.match(\n                r'^https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{{1,256}}\\.[a-zA-Z0-9()]{{1,6}}\\b(?:[-a-zA-Z0-9()@:%_\\+.~#?&\\/=]*)$',\n                self.value\n            ):\n                raise ValueError(f"Invalid URL: {self.value}")\n        \n        elif self.ioc_type == IOCType.EMAIL:\n            if not re.match(\n                r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$',\n                self.value\n            ):\n                raise ValueError(f"Invalid email: {self.value}")\n        \n        # Additional validations for other IOC types can be added here\n    \n    def to_dict(self) -> Dict[str, Any]:\n        """Convert the IOC to a dictionary."""\n        result = asdict(self)\n        result['ioc_type'] = self.ioc_type.value\n        return result\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'IOC':\n        """Create an IOC from a dictionary."""\n        if 'ioc_type' in data and isinstance(data['ioc_type'], str):\n            data['ioc_type'] = IOCType(data['ioc_type'])\n        return cls(**data)\n\n@dataclass\nclass HuntingRule:\n    """Represents a threat hunting rule."""\n    id: str\n    name: str\n    description: str\n    technique: HuntingTechnique\n    query: Dict[str, Any]\n    severity: AlertSeverity = AlertSeverity.MEDIUM\n    enabled: bool = True\n    tags: List[str] = field(default_factory=list)\n    author: Optional[str] = None\n    created: Optional[datetime.datetime] = None\n    updated: Optional[datetime.datetime] = None\n    references: List[str] = field(default_factory=list)\n    false_positives: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        """Initialize timestamps if not provided."""\n        now = datetime.datetime.utcnow()\n        if self.created is None:\n            self.created = now\n        if self.updated is None:\n            self.updated = now\n    \n    def to_dict(self) -> Dict[str, Any]:\n        """Convert the rule to a dictionary."""\n        result = asdict(self)\n        result['technique'] = self.technique.value\n        result['severity'] = self.severity.value\n        return result\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'HuntingRule':\n        """Create a rule from a dictionary."""\n        if 'technique' in data and isinstance(data['technique'], str):\n            data['technique'] = HuntingTechnique(data['technique'])\n        if 'severity' in data and isinstance(data['severity'], str):\n            data['severity'] = AlertSeverity[data['severity']]\n        return cls(**data)\n\nclass ThreatHunter:\n    """Main class for threat hunting operations."""\n    \n    def __init__(self, config: Dict[str, Any]):\n        """Initialize the threat hunter."""\n        self.config = config\n        self.logger = logging.getLogger('edr.threat_hunting.hunter')\n        self.ioc_manager = IOCManager(config.get('ioc', {}))\n        self.rule_manager = RuleManager(config.get('rules', {}))\n        self.data_sources = self._initialize_data_sources()\n        self.enabled = config.get('enabled', True)\n        self.scan_interval = config.get('scan_interval', 3600)  # seconds\n        self.last_scan_time = None\n        self.is_scanning = False\n        self._stop_event = None\n    \n    def _initialize_data_sources(self) -> Dict[str, Any]:\n        """Initialize data sources for threat hunting."""\n        # This would be replaced with actual data source initialization\n        return {\n            'processes': ProcessDataSource(),\n            'files': FileDataSource(),\n            'network': NetworkDataSource(),\n            'registry': RegistryDataSource(),\n            'logs': LogDataSource(),\n            'memory': MemoryDataSource()\n        }\n    \n    def start(self) -> None:\n        """Start the threat hunting service."""\n        if not self.enabled:\n            self.logger.info("Threat hunting is disabled in configuration")\n            return\n        \n        self._stop_event = False\n        self.logger.info("Starting threat hunting service")\n        \n        # Start background scanner\n        import threading\n        self.scanner_thread = threading.Thread(\n            target=self._background_scanner,\n            name="ThreatHunter-Scanner",\n            daemon=True\n        )\n        self.scanner_thread.start()\n    \n    def stop(self) -> None:\n        """Stop the threat hunting service."""\n        self.logger.info("Stopping threat hunting service")\n        self._stop_event = True\n        if hasattr(self, 'scanner_thread') and self.scanner_thread.is_alive():\n            self.scanner_thread.join(timeout=30)\n    \n    def _background_scanner(self) -> None:\n        """Background scanner that runs hunting rules at regular intervals."""\n        self.logger.info("Background threat hunter started")\n        \n        while not self._stop_event:\n            try:\n                if self.last_scan_time is None or \n                   (time.time() - self.last_scan_time) >= self.scan_interval:\n                    self.run_hunting_rules()\n                    self.last_scan_time = time.time()\n                time.sleep(60)  # Check every minute\n            except Exception as e:\n                self.logger.error(f"Error in background scanner: {e}", exc_info=True)\n                time.sleep(300)  # Wait 5 minutes after an error\n    \n    def run_hunting_rules(self, rule_ids: Optional[List[str]] = None) -> List[Alert]:\n        """\n        Run all enabled hunting rules or specific rules if IDs are provided.\n        \n        Args:\n            rule_ids: Optional list of rule IDs to run. If None, all enabled rules are run.\n            \n        Returns:\n            List of alerts generated by the hunting rules.\n        """\n        if self.is_scanning:\n            self.logger.warning("A scan is already in progress")\n            return []\n        \n        self.is_scanning = True\n        alerts = []\n        \n        try:\n            # Get rules to run\n            if rule_ids:\n                rules = [self.rule_manager.get_rule(rule_id) for rule_id in rule_ids]\n                rules = [r for r in rules if r is not None]\n            else:\n                rules = self.rule_manager.get_enabled_rules()\n            \n            self.logger.info(f"Running {len(rules)} hunting rules")\n            \n            # Run rules in parallel\n            with concurrent.futures.ThreadPoolExecutor(\n                max_workers=self.config.get('max_workers', 5)\n            ) as executor:\n                future_to_rule = {\n                    executor.submit(self._run_rule, rule): rule\n                    for rule in rules\n                }\n                \n                for future in concurrent.futures.as_completed(future_to_rule):\n                    rule = future_to_rule[future]\n                    try:\n                        rule_alerts = future.result()\n                        alerts.extend(rule_alerts)\n                    except Exception as e:\n                        self.logger.error(\n                            f"Error running rule {rule.id}: {e}",\n                            exc_info=True\n                        )\n            \n            self.logger.info(f"Hunting completed. Generated {len(alerts)} alerts")\n            return alerts\n            \n        except Exception as e:\n            self.logger.error(f"Error running hunting rules: {e}", exc_info=True)\n            return []\n        finally:\n            self.is_scanning = False\n    \n    def _run_rule(self, rule: HuntingRule) -> List[Alert]:\n        """Run a single hunting rule and return any alerts."""\n        alerts = []\n        start_time = time.time()\n        \n        try:\n            self.logger.debug(f"Running hunting rule: {rule.id} - {rule.name}")\n            \n            # Execute the appropriate query based on the technique\n            if rule.technique == HuntingTechnique.IOC_MATCH:\n                results = self._run_ioc_query(rule.query)\n            elif rule.technique == HuntingTechnique.BEHAVIORAL:\n                results = self._run_behavioral_query(rule.query)\n            elif rule.technique == HuntingTechnique.ANOMALY_DETECTION:\n                results = self._run_anomaly_detection(rule.query)\n            elif rule.technique == HuntingTechnique.MEMORY_ANALYSIS:\n                results = self._run_memory_analysis(rule.query)\n            else:\n                self.logger.warning(f"Unsupported hunting technique: {rule.technique}")\n                return []\n            \n            # Process results\n            for result in results:\n                alert = self._create_alert_from_result(rule, result)\n                if alert:\n                    alerts.append(alert)\n            \n            duration = time.time() - start_time\n            self.logger.info(\n                f"Rule {rule.id} completed in {duration:.2f}s. "\n                f"Found {len(alerts)} matches."\n            )\n            \n            return alerts\n            \n        except Exception as e:\n            self.logger.error(\n                f"Error running rule {rule.id}: {e}",\n                exc_info=True\n            )\n            return []\n    \n    def _run_ioc_query(self, query: Dict[str, Any]) -> List[Dict[str, Any]]:\n        """Run an IOC-based query."""\n        # This is a simplified example. In a real implementation, this would\n        # query various data sources for matches against the IOCs.\n        results = []\n        \n        # Get IOCs from the query\n        iocs = query.get('iocs', [])\n        if not iocs:\n            return []\n        \n        # Get data source\n        data_source_name = query.get('data_source', 'all')\n        if data_source_name == 'all':\n            data_sources = self.data_sources.values()\n        else:\n            data_sources = [self.data_sources.get(data_source_name)]\n        \n        # Search for IOC matches in each data source\n        for data_source in data_sources:\n            if not data_source:\n                continue\n                \n            for ioc in iocs:\n                try:\n                    if not isinstance(ioc, dict):\n                        ioc = {'value': ioc}\n                    \n                    ioc_obj = IOC.from_dict(ioc) if isinstance(ioc, dict) else ioc\n                    matches = data_source.search_ioc(ioc_obj)\n                    results.extend(matches)\n                except Exception as e:\n                    self.logger.error(\n                        f"Error searching for IOC {ioc}: {e}",\n                        exc_info=True\n                    )\n        \n        return results\n    \n    def _run_behavioral_query(self, query: Dict[str, Any]) -> List[Dict[str, Any]]:\n        """Run a behavioral query."""\n        # This is a simplified example. In a real implementation, this would\n        # analyze behavior patterns across various data sources.\n        results = []\n        \n        # Get the behavior pattern\n        pattern = query.get('pattern')\n        if not pattern:\n            return []\n        \n        # Get data source\n        data_source_name = query.get('data_source')\n        if not data_source_name:\n            self.logger.error("No data source specified for behavioral query")\n            return []\n        \n        data_source = self.data_sources.get(data_source_name)\n        if not data_source:\n            self.logger.error(f"Unknown data source: {data_source_name}")\n            return []\n        \n        # Execute the behavioral query\n        try:\n            results = data_source.query_behavior(pattern)\n        except Exception as e:\n            self.logger.error(\n                f"Error running behavioral query on {data_source_name}: {e}",\n                exc_info=True\n            )\n        \n        return results\n    \n    def _run_anomaly_detection(self, query: Dict[str, Any]) -> List[Dict[str, Any]]:\n        """Run anomaly detection."""\n        # This is a placeholder. In a real implementation, this would use\n        # statistical or machine learning models to detect anomalies.\n        return []\n    \n    def _run_memory_analysis(self, query: Dict[str, Any]) -> List[Dict[str, Any]]:\n        """Run memory analysis."""\n        # This is a placeholder. In a real implementation, this would analyze\n        # process memory for signs of malicious activity.\n        return []\n    \n    def _create_alert_from_result(\n        self,\n        rule: HuntingRule,\n        result: Dict[str, Any]\n    ) -> Optional[Alert]:\n        """Create an alert from a hunting result."""\n        try:\n            # Extract relevant information from the result\n            title = f"Threat Hunting Alert: {rule.name}"\n            description = rule.description\n            \n            if 'description' in result:\n                description += f"\\n\\nDetails: {result['description']}"\n            \n            # Create the alert\n            alert = Alert(\n                alert_id=f"threat_hunt_{rule.id}_{int(time.time())}",\n                title=title,\n                description=description,\n                severity=rule.severity,\n                source="threat_hunting",\n                metadata={\n                    'rule_id': rule.id,\n                    'rule_name': rule.name,\n                    'technique': rule.technique.value,\n                    'query': rule.query,\n                    'result': result,\n                    'tags': rule.tags,\n                    'references': rule.references\n                }\n            )\n            \n            return alert\n            \n        except Exception as e:\n            self.logger.error(\n                f"Error creating alert from hunting result: {e}",\n                exc_info=True\n            )\n            return None\n\n# Example data source classes (simplified for demonstration)\nclass DataSource:\n    """Base class for data sources."""\n    def search_ioc(self, ioc: IOC) -> List[Dict[str, Any]]:\n        """Search for an IOC in this data source."""\n        raise NotImplementedError\n    \n    def query_behavior(self, pattern: Dict[str, Any]) -> List[Dict[str, Any]]:\n        """Query for behavioral patterns in this data source."""\n        raise NotImplementedError\n\nclass ProcessDataSource(DataSource):\n    """Data source for process information."""\n    def search_ioc(self, ioc: IOC) -> List[Dict[str, Any]]:\n        # In a real implementation, this would search running processes\n        # for matches against the IOC\n        return []\n    \n    def query_behavior(self, pattern: Dict[str, Any]) -> List[Dict[str, Any]]:\n        # In a real implementation, this would analyze process behavior\n        return []\n\nclass FileDataSource(DataSource):\n    """Data source for file system information."""\n    def search_ioc(self, ioc: IOC) -> List[Dict[str, Any]]:\n        # In a real implementation, this would search the file system\n        # for matches against the IOC\n        return []\n    \n    def query_behavior(self, pattern: Dict[str, Any]) -> List[Dict[str, Any]]:\n        # In a real implementation, this would analyze file system behavior\n        return []\n\nclass NetworkDataSource(DataSource):\n    """Data source for network information."""\n    def search_ioc(self, ioc: IOC) -> List[Dict[str, Any]]:\n        # In a real implementation, this would search network connections\n        # for matches against the IOC\n        return []\n    \n    def query_behavior(self, pattern: Dict[str, Any]) -> List[Dict[str, Any]]:\n        # In a real implementation, this would analyze network behavior\n        return []\n\nclass RegistryDataSource(DataSource):\n    """Data source for Windows Registry information."""\n    def search_ioc(self, ioc: IOC) -> List[Dict[str, Any]]:\n        # In a real implementation, this would search the registry\n        # for matches against the IOC\n        return []\n    \n    def query_behavior(self, pattern: Dict[str, Any]) -> List[Dict[str, Any]]:\n        # In a real implementation, this would analyze registry behavior\n        return []\n\nclass LogDataSource(DataSource):\n    """Data source for log data."""\n    def search_ioc(self, ioc: IOC) -> List[Dict[str, Any]]:\n        # In a real implementation, this would search logs\n        # for matches against the IOC\n        return []\n    \n    def query_behavior(self, pattern: Dict[str, Any]) -> List[Dict[str, Any]]:\n        # In a real implementation, this would analyze log patterns\n        return []\n\nclass MemoryDataSource(DataSource):\n    """Data source for memory analysis."""\n    def search_ioc(self, ioc: IOC) -> List[Dict[str, Any]]:\n        # In a real implementation, this would search process memory\n        # for matches against the IOC\n        return []\n    \n    def query_behavior(self, pattern: Dict[str, Any]) -> List[Dict[str, Any]]:\n        # In a real implementation, this would analyze memory behavior\n        return []\n\n# Example usage\nif __name__ == "__main__":\n    # Example configuration\n    config = {\n        'enabled': True,\n        'scan_interval': 3600,  # 1 hour\n        'max_workers': 5,\n        'ioc': {\n            'sources': [\n                'local',\n                'threat_intel_feeds'\n            ],\n            'update_interval': 86400  # 24 hours\n        },\n        'rules': {\n            'path': 'hunting_rules',\n            'auto_reload': True\n        }\n    }\n    \n    # Initialize the threat hunter\n    hunter = ThreatHunter(config)\n    \n    # Example: Add an IOC to hunt for\n    malicious_ip = IOC(\n        value="192.168.1.100",\n        ioc_type=IOCType.IPV4,\n        source="threat_intel",\n        tags=["malware", "c2"],\n        description="Known malicious C2 server",\n        confidence=0.9\n    )\n    \n    # Example: Run a hunting rule\n    rule = HuntingRule(\n        id="hunt-c2-communication",\n        name="C2 Communication Detection",\n        description="Detects communication with known C2 servers",\n        technique=HuntingTechnique.IOC_MATCH,\n        severity=AlertSeverity.HIGH,\n        query={\n            'iocs': [malicious_ip.to_dict()],\n            'data_source': 'network'\n        },\n        tags=["c2", "network", "ioc"]\n    )\n    \n    # Start the hunter\n    hunter.start()\n    \n    try:\n        # Run the hunting rule manually\n        alerts = hunter.run_hunting_rules(["hunt-c2-communication"])\n        print(f"Generated {len(alerts)} alerts")\n        \n        # Keep the service running\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        print("Stopping threat hunter...")\n        hunter.stop()
